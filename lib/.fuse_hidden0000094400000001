
#include "MonteCarlo.h"
#include <cstddef>
#include <cmath>
#include <ctime>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>
#include <limits>
using namespace std;

string spinComponent[SPINDIMEN] = {
"X direction",
"Y direction",
"Z direction",
"XY direction",
"YZ direction",
"ZX direction",
"PsuedoX",
"PseudoY",
"PseudoZ"
};
string spinComponentSmall[SPINDIMEN] = {
"X",
"Y",
"Z",
"XY",
"YZ",
"ZX",
"PX",
"PY",
"PZ"
};
string powerOP[POWERSOP] = {
" to the 1st power",
" to the 2nd power",
" to the 3rd power",
" to the 4th power"
};
string typeOP[TYPESOP] = {
"Order Parameter",
"Cubic Order Parameter, b1",
"Cubic Order Parameter, b2",
"Magnitude of Cubic Order Parameter, |b|",
"Order Parameter, m1",
"Order Parameter, m2",
"Magnitude of Order Parameter, |m|",
"X Component of the Spin",
"Y Component of the Spin",
"Z Component of the Spin",
"XY Component of the Spin",
"YZ Component of the Spin",
"ZX Component of the Spin",
"X Component of the Pseudospin",
"Y Component of the Pseudospin",
"Z Component of the Pseudospin",
"Order Parameter of Pseudospin"
};
//First, an array is created for each order parameter
//The array is the number of elements as the spin dimension
//the array is added to in order to create the order parameter * N.
//At the end, we have a sum over the lattice - each spin has been summed over.
//The M order Parameter will keep track of strickly the spin component summed.
//From here, The typeOP are generated by manipulating the sum average spin -
//the snapshot of the entire lattice which computes these.
string orderParameter[NUMVECTORS] = {
"Magnetization",
"Neel",
"Stripy-1",
"Stripy-2",
"Stripy-3",
"Stripy",
"Neel-3D",
"ZigZag-1",
"ZigZag-2",
"ZigZag-3",
"ZigZag"
};
string orderParameterSmall[NUMVECTORS] = {
"M",
"N",
"S1",
"S2",
"S3",
"S",
"N3D",
"ZZ1",
"ZZ2",
"ZZ3",
"ZZ"
};
string sumOPNames       [NUMVECTORS][TYPESOP][POWERSOP] = {""};
string charOPNames      [NUMVECTORS][TYPESOP] = {""};

double MonteCarlo::dotProd(const double arr1[], const double arr2[]){
    return (arr1[0] * arr2[0] +
            arr1[1] * arr2[1] +
            arr1[2] * arr2[2]);
}

double MonteCarlo::getPolarAngleTB(double spinX, double spinY, double spinZ){
    //OP: TB, Polar Angle to B Field
    double Bfield[3] = {0};
    Bfield[0] = COMPONENTOFBFIELDIN_X_DIRECTION;
    Bfield[1] = COMPONENTOFBFIELDIN_Y_DIRECTION;
    Bfield[2] = COMPONENTOFBFIELDIN_Z_DIRECTION;
    double spin[3] = {0};
    spin[0] = spinX;
    spin[1] = spinY;
    spin[2] = spinZ;
    
    double normB = sqrt(dotProd(Bfield,Bfield));
    double normS = sqrt(dotProd(spin,spin));
    double cosTB = dotProd(spin, Bfield)/(normB * normS);
    
    if((cosTB > 1.0000001)||(cosTB < -1.00000001)){
        cout<<"bad TB "<<cosTB<<endl; 
        cerr<<"bad TB "<<cosTB<<endl; 
        exit(1);
    }
    if((cosTB > 1.0)){
        cosTB = 1;
    }
    if((cosTB < -1.0)){
        cosTB = -1;
    }
    
    return acos(cosTB);
    //End OP TB
    
}

double MonteCarlo::getAziAngleAB(double spinX, double spinY, double spinZ){
    //OP: AB, Azimuthal Angle to the B Field
    
    /*
     Unlike finding the polar angle to the B field, the azimuthal angle is
     slightly more subtle. To completely specify the orientation of the
     azimuthal angle, we will construct a right handed coordinate system which
     will fully define the azimuthal angle.
     If the direction of the B field is analogous to a "z" direction,
     then define n to be analogous to the "x" direction via: n = B x z
     where B is the direction of the external field and z is the "c"crystal axis.
     if B is along z, then let n = x. where x is the "a" crystal axis.
     Finally, we define m = B x n - analogous to the "b" crystal axis.
     */
    
    double Bfield[3] = {0};
    Bfield[0] = COMPONENTOFBFIELDIN_X_DIRECTION;
    Bfield[1] = COMPONENTOFBFIELDIN_Y_DIRECTION;
    Bfield[2] = COMPONENTOFBFIELDIN_Z_DIRECTION;
    double normB = sqrt(dotProd(Bfield,Bfield));
    
    Bfield[0] = Bfield[0] / normB;
    Bfield[1] = Bfield[1] / normB;
    Bfield[2] = Bfield[2] / normB;
    
    double spin[3] = {0};
    spin[0] = spinX;
    spin[1] = spinY;
    spin[2] = spinZ;
    double normS = sqrt(dotProd(spin,spin));
    
    spin[0] = spin[0] / normS;
    spin[1] = spin[1] / normS;
    spin[2] = spin[2] / normS;
    
    //Bfield is analogous to the z direction
    //nhat = B cross zhat - This is analogous to the x direction
    double nhat[3] = {0};
    nhat[0] = COMPONENTOFBFIELDIN_Y_DIRECTION;//y->x in cross products
    nhat[1] = (-1)*COMPONENTOFBFIELDIN_X_DIRECTION;
    nhat[2] = 0;
    
    if(fabs(COMPONENTOFBFIELDIN_Z_DIRECTION - 1) < 1e-5){
        nhat[0] = 1;
        nhat[1] = 0;
        nhat[2] = 0;
    }
    if(fabs(COMPONENTOFBFIELDIN_Z_DIRECTION - (-1)) < 1e-5){
        nhat[0] = -1;
        nhat[1] = 0;
        nhat[2] = 0;
    }
    
    double normN = sqrt(dotProd(nhat, nhat));
    nhat[0] = nhat[0] / normN;
    nhat[1] = nhat[1] / normN;
    nhat[2] = nhat[2] / normN;
    
    //Third axis definition, the resultant from B x n
    double vert[3] = {0};
    vert[0] =           Bfield[1] * nhat[2] - Bfield[2] * nhat[1];
    vert[1] = (-1) *   (Bfield[0] * nhat[2] - Bfield[2] * nhat[0]);
    vert[2] =           Bfield[0] * nhat[1] - Bfield[1] * nhat[0];
    double normV = sqrt(dotProd(vert, vert));
    vert[0] = vert[0] / normV;
    vert[1] = vert[1] / normV;
    vert[2] = vert[2] / normV;
    
    //projecting the spin into the plane perpendicular to the B field.
    double spinProjIntoPerpPlane[3] = {0};
    spinProjIntoPerpPlane[0] = spinX - (dotProd(spin, Bfield) * Bfield[0]/dotProd(Bfield, Bfield));
    spinProjIntoPerpPlane[1] = spinY - (dotProd(spin, Bfield) * Bfield[1]/dotProd(Bfield, Bfield)); 
    spinProjIntoPerpPlane[2] = spinZ - (dotProd(spin, Bfield) * Bfield[2]/dotProd(Bfield, Bfield)); 
    double normSP = sqrt(dotProd(spinProjIntoPerpPlane, spinProjIntoPerpPlane));
    spinProjIntoPerpPlane[0] = spinProjIntoPerpPlane[0] / normSP;
    spinProjIntoPerpPlane[1] = spinProjIntoPerpPlane[1] / normSP;
    spinProjIntoPerpPlane[2] = spinProjIntoPerpPlane[2] / normSP;
    
    //At this point, the dot product of spinProjIntoPerpPlane with nhat will
    //yield cos(AB). But this is sign insensitive - choose nhat to be the "x"
    //and ccw, [0,2pi) is the AB angle. This means that when the dot product of
    //vert and spinProjIntoPerpPlane are greater than 0, then 0 < AB < pi and
    //vert and spinProjIntoPerpPlane are less than 0, then pi < AB < 2pi.
    
    if(dotProd(spinProjIntoPerpPlane, vert) == 0){
        if(dotProd(spinProjIntoPerpPlane, nhat) > 0){
            return 0;
        }else{
            return PI;
        }
    }
    
    double cosAB = dotProd(spinProjIntoPerpPlane, nhat);
    if((cosAB > 1.0000001)||(cosAB < -1.00000001)){
        cout<<"bad AB "<<cosAB<<endl; 
        cerr<<"bad AB "<<cosAB<<endl; 
        exit(1);
    }
    if((cosAB > 1.0)){
        cosAB = 1;
    }
    if((cosAB < -1.0)){
        cosAB = -1;
    }
    double OPAB = acos(cosAB);
    
    if(dotProd(spinProjIntoPerpPlane, vert) < 0){
        OPAB = 2 * PI - OPAB;
    }
    
    return OPAB;
    
    //End OP: AB
}

void MonteCarlo::setCharsToZero(){
    cout<<"Set Lat Chars to Zero"<<endl;
    
    //Setting Lat Chars to zero.
    for(int i = 0; i < POWERSOP; i++){
        LC.sumE[i] = 0;
        LC.sumTB[i] = 0;
        LC.sumAB[i] = 0;
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                LC.sumOP[i][j][k] = 0;
            }
        }
    }
    
    //Setting correlation function to zero
    for(int count = 0; count < cellsA*2; count++){
        LC.sumECorrFunc[count] = 0;
        LC.sumTBCorrFunc[count] = 0;
        LC.sumABCorrFunc[count] = 0;
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                LC.sumOPCorrFunc[i][j][count] = 0;
            }
        }
    }
    
    //Fill the array's names
    stringstream name;
    for(int i = 0; i < NUMVECTORS; i ++){
        for(int j = 0; j < TYPESOP; j++){
            name.str("");
            name << orderParameter[i] << "'s "<< typeOP[j];
            charOPNames[i][j] = name.str();
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i ++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                name.str("");
                name << orderParameter[i] << "'s "<< typeOP[j] << powerOP[k];
                sumOPNames[i][j][k] = name.str();
            }
        }
    }
}

void MonteCarlo::initializeLattice(){
    //Constructs and initializes the lattice to random spins
    ClassicalSpin3D spin;
    for(int i = 0; i < cellsA; i++){
        std::vector< std::vector< std::vector<ClassicalSpin3D> > > row;
        for(int j = 0; j < cellsB; j++){
            std::vector< std::vector<ClassicalSpin3D> > col;
            for(int k = 0; k < 2; k++){
                std::vector<ClassicalSpin3D> rise;
                for(int z = 0; z < cellsC; z++){
                    rise.push_back(spin);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        lattice.push_back(row);
    }
    
    
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < cellsC; z++){
                    lattice[i][j][k][z].setRandomOrientation();
                    lattice[i][j][k][z].setX(i+1);//edit
                    lattice[i][j][k][z].setY(j+1);//edit
                    lattice[i][j][k][z].setZ(k+1);//edit
                    lattice[i][j][k][z].setPosX(i);
                    lattice[i][j][k][z].setPosY(j);
                    lattice[i][j][k][z].setPosS(k);
                    lattice[i][j][k][z].setPosZ(z);
                    lattice[i][j][k][z].checkSpin();
                }
            }
        }
    }
}

void MonteCarlo::setSpinComponent(string component){
    int xPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int yPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int zPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int sPos = atoi(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double xComp = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double yComp = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double zComp = atof(component.substr(0,component.find(" ")).c_str());
    lattice[xPos][yPos][sPos][zPos].setX(xComp);
    lattice[xPos][yPos][sPos][zPos].setY(yComp);
    lattice[xPos][yPos][sPos][zPos].setZ(zComp);
    cout<< "Component: " << xPos << " " << yPos << " " << sPos << " " <<
    zPos << " " << xComp<< " " << yComp << " " << zComp<<endl;
}

double MonteCarlo::findParameterDbl(double currentValue, string l, string str) const{
    if(l.find(str.c_str()) != string::npos){
        return atof(l.substr(str.size()).c_str());
    }else{
        return currentValue;
    }
}

int MonteCarlo::findParameterInt(int currentValue, string line, string search) const{
    if(line.find(search.c_str()) != string::npos){
        return atoi(line.substr(search.size()).c_str());
    }else{
        return currentValue;
    }
}

MonteCarlo::MonteCarlo(){
    
    //initialize private variables
    cellsA      = 2;
    cellsB      = 2;
    cellsC      = 1;
    alpha       = 0;
    extMagField = 0;
    param1      = 0;
    param2      = 0;
    
    flipAttempts    = 0;
    successfulFlips = 0;
    KbT             = 0;
    range           = PI-0.1;
    rangeOld        = 0.1;
    configurations  = 0;
    outputMag       = "";
    setCharsToZero();
    
    initializeLattice();
    
    cout<<"Finished with default MC constructor"<<endl;
    
}

MonteCarlo::MonteCarlo(double KbT_, int cellsA_, int cellsB_, int cellsC_,
                       double alpha_, double extMagField_, double param1_,
                       double param2_, string path_){
    
    //initialize private variables
    cellsA      = cellsA_;
    cellsB      = cellsB_;
    cellsC      = cellsC_;
    alpha       = alpha_;
    extMagField = extMagField_;
    param1      = param1_;
    param2      = param2_;
    
    flipAttempts    = 0;
    successfulFlips = 0;
    outputMag       = path_;
    KbT             = KbT_;
    range           = PI-0.1;
    rangeOld        = 0.1;
    configurations  = 0;
    setCharsToZero();
    
    initializeLattice();
    
    //Runs the lattice without taking data at these temperatures to get the
    //spins pointed in approximately the correct direction.
   //edit thermalize(KbT_ * 16);
   //edit thermalize(KbT_ * 4);
   //edit thermalize(KbT_ * 2);
   //edit thermalize(KbT_);
    setCharsToZero();
    
    cout<<"Finished with (new) MC constructor"<<endl;
}

MonteCarlo::MonteCarlo(string path_, string name){
    
    //initialize private variables. This is unnecessary.
    cellsA      = 0;
    cellsB      = 0;
    cellsC      = 0;
    alpha       = 0;
    extMagField = 0;
    param1      = 0;
    param2      = 0;
    
    setCharsToZero();
    configurations = 0;
    
    //Reading in the rest of the lattice information from the saved file
    char path[512];
    getcwd(path, 512);
    stringstream concat;
    concat.str("");
    concat << path_ << name;
    outputMag = concat.str();
    
    string line = "";
    ifstream file;
    file.clear();
    file.open(outputMag.c_str());
    if (!file.is_open() || !file.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    line = "";
    string search = "";
    while(file.good()){
        getline (file,line);
        if(line.find("End information for this configuration") !=
           string::npos){
            break;
        }
        
        //Retrieving the lattice properties from the text file
        cellsA = findParameterInt(cellsA, line, "Cells-A: ");
        cellsB = findParameterInt(cellsB, line, "Cells-B: ");
        cellsC = findParameterInt(cellsC, line, "Cells-C: ");
        KbT = findParameterDbl(KbT, line, "KbT: ");
        alpha = findParameterDbl(alpha, line, "Alpha: ");
        extMagField = findParameterDbl(extMagField, line,
                                       "External Magnetic Field: ");
        param1 = findParameterDbl(param1, line, "Parameter-1: ");
        param2 = findParameterDbl(param2, line, "Parameter-2: ");
        configurations = findParameterInt(configurations, line, "Configurations: ");
        range = findParameterDbl(range, line, "Flip Range: ");
        
        //Saving the Lattice Characteristics
        stringstream ss;
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                for(int k = 0; k < POWERSOP; k++){
                    ss.str("");
                    ss << "Sum over Configurations, " << sumOPNames[i][j][k] << ": ";
                    LC.sumOP[i][j][k] = findParameterDbl(LC.sumOP[i][j][k], line,
                                                         ss.str());
                }
            }
        }
        //E
        ss.str("");
        ss << "Sum over Configurations, Energy to the 1st power: ";
        LC.sumE[0] = findParameterDbl(LC.sumE[0], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Energy to the 2nd power: ";
        LC.sumE[1] = findParameterDbl(LC.sumE[1], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Energy to the 3rd power: ";
        LC.sumE[2] = findParameterDbl(LC.sumE[2], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Energy to the 4th power: ";
        LC.sumE[3] = findParameterDbl(LC.sumE[3], line, ss.str());
        //TB
        ss.str("");
        ss << "Sum over Configurations, Polar Angle to B Field to the 1st power: ";
        LC.sumTB[0] = findParameterDbl(LC.sumTB[0], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Polar Angle to B Field to the 2nd power: ";
        LC.sumTB[1] = findParameterDbl(LC.sumTB[1], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Polar Angle to B Field to the 3rd power: ";
        LC.sumTB[2] = findParameterDbl(LC.sumTB[2], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Polar Angle to B Field to the 4th power: ";
        LC.sumTB[3] = findParameterDbl(LC.sumTB[3], line, ss.str());
        //AB
        ss.str("");
        ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 1st power: ";
        LC.sumAB[0] = findParameterDbl(LC.sumAB[0], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 2nd power: ";
        LC.sumAB[1] = findParameterDbl(LC.sumAB[1], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 3rd power: ";
        LC.sumAB[2] = findParameterDbl(LC.sumAB[2], line, ss.str());
        ss.str("");
        ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 4th power: ";
        LC.sumAB[3] = findParameterDbl(LC.sumAB[3], line, ss.str());
        //End explicit labeling for scalar quantities
        
        //Correlation function
        for(int count = 0; count < cellsA*2; count++){
            for(int i = 0; i < NUMVECTORS; i++){
                for(int j = 0; j < TYPESOP; j++){
                    ss.str("");
                    ss << "Sum over Configurations, Correlation Function - ";
                    ss << "between " << count << " Nearest Neighbors - ";
                    ss << charOPNames[i][j] << ": ";
                    LC.sumOPCorrFunc[i][j][count] = findParameterDbl(LC.sumOPCorrFunc[i][j][count],
                                                                     line, ss.str());
                }
            }
        }
        for(int count = 0; count < cellsA*2; count++){
            //E
            ss.str("");
            ss << "Sum over Configurations, Correlation Function - ";
            ss << "between " << count << " Nearest Neighbors - ";
            ss << "Energy to the 1st power: ";
            LC.sumECorrFunc[count] = findParameterDbl(LC.sumECorrFunc[count], line, ss.str());
            //TB
            ss.str("");
            ss << "Sum over Configurations, Correlation Function - ";
            ss << "between " << count << " Nearest Neighbors - ";
            ss << "Polar Angle to B Field to the 1st power: ";
            LC.sumTBCorrFunc[count] = findParameterDbl(LC.sumTBCorrFunc[count], line, ss.str());
            //AB
            ss.str("");
            ss << "Sum over Configurations, Correlation Function - ";
            ss << "between " << count << " Nearest Neighbors - ";
            ss << "Azimuthal Angle to the B Field to the 1st power: ";
            LC.sumABCorrFunc[count] = findParameterDbl(LC.sumABCorrFunc[count], line, ss.str());
        }
    }
    
    cout<<"Finished with reading in all lattice chars"<<endl;
    file.close();
    
    initializeLattice();  
    
    //Copying Spin Components
    line = "";
    file.clear();
    file.open(outputMag.c_str());
    if (!file.is_open() || !file.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    line = "";
    search = "";
    while(file.good()){
        getline (file,line);
        if(line.find("End information for this configuration") !=
           string::npos){
            break;
        }
        search = "Components of Spin ";
        if(line.find(search.c_str()) != string::npos){
            setSpinComponent(line.substr(search.size()).c_str());
        }
    }
    file.close();
    
    cout<<"Finished with reading in all components"<<endl;
    
    //configurations = 0;
    
    //If configuartions is set to 0, then we want to run this from scratch
    if(configurations == 0){
        cout<<"configurations = 0"<<endl;
        setCharsToZero();
        
        for(int i = 0; i < cellsA; i++){
            for(int j = 0; j < cellsB; j++){
                for(int k = 0; k < 2; k++){
                    for(int z = 0; z < cellsC; z++){
                        lattice[i][j][k][z].setRandomOrientation();
                    }
                }
            }
        }
        double KbT_ = KbT;
        thermalize(KbT_ * 16);
        thermalize(KbT_ * 4);
        thermalize(KbT_ * 2);
        thermalize(KbT_);
        setCharsToZero();
    }
    
    flipAttempts    = 0;
    successfulFlips = 0;
    rangeOld        = 0.1;
    //"range" is set either by reading in, or by "thermalize()".
    
    //Done initializing, now to print out the starting characteristics; as check
    stringstream stream;
    stream.str("");
    stream << "Cells-A: " << cellsA << endl;
    stream << "Cells-B: " << cellsB << endl;
    stream << "Cells-C: " << cellsC << endl;
    stream << "KbT: " << KbT << endl;
    stream << "Alpha: " << alpha << endl;
    stream << "External Magnetic Field: " << extMagField << endl;
    stream << "Parameter-1: " << param1 << endl;
    stream << "Parameter-2: " << param2 << endl;
    stream << "Configurations: " << configurations << endl;
    stream << "Flip Success percentage: " << successfulFlips/flipAttempts<<endl;
    stream << "Flip Range: " << range << endl;
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Current Snapshot, " << charOPNames[i][j] << ": ";
            stream << std::scientific << std::setprecision(PR) << OP.charOP[i][j] << endl;
        }
    }
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                stream << "Sum over Configurations, " << sumOPNames[i][j][k] << ": ";
                stream << std::scientific << std::setprecision(PR) << LC.sumOP[i][j][k] << endl;
            }
        }
    }
    //E
    stream << "Current Snapshot, Energy: ";
    stream << std::scientific << std::setprecision(PR) << OP.E << endl;
    stream << "Sum over Configurations, Energy to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[0] << endl;
    stream << "Sum over Configurations, Energy to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[1] << endl;
    stream << "Sum over Configurations, Energy to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[2] << endl;
    stream << "Sum over Configurations, Energy to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[3] << endl;
    //TB
    stream << "Current Snapshot, Polar Angle to B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.TB << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[0] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[1] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[2] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[3] << endl;
    //AB
    stream << "Current Snapshot, Azimuthal Angle to the B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.AB << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[0] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[1] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[2] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[3] << endl;
    
    //Correlation function
    for(int count = 0; count < cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Sum over Configurations, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << LC.sumOPCorrFunc[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << LC.sumECorrFunc[count] << endl;
    }
    //TB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << LC.sumTBCorrFunc[count] << endl;
    }
    //AB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << LC.sumABCorrFunc[count] << endl;
    }
    
    //Snapshot of M
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    stream << "Components of Spin " << i << "," << j << "," <<
                    z << "," << k << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getX() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getY() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getZ() << endl;
                }
            }
        }
    }
    cout << stream.str() << endl;
    
    cout<<"Finished with MC constructor"<<endl;
    
}

void MonteCarlo::metropolisSweep(){ 
    double   changeInEnergy  = 0;
    double   initialEnergy   = 0;
    double   finalEnergy     = 0;
    
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < cellsC; z++)
                {
                    
                    //getSpin(i, j, k).checkSpin();
                    initialEnergy = getLocalEnergy(lattice[i][j][k][z]);
                    lattice[i][j][k][z].flip(range);
                    finalEnergy = getLocalEnergy(lattice[i][j][k][z]);
                    changeInEnergy = finalEnergy - initialEnergy;
                    flipAttempts += 1;
                    successfulFlips += 1;
                    //The lattice automatically keeps the spin flip unless the
                    //energy is > 0
                    
                    if(changeInEnergy > 0)
                    {
                        /**
                         *Then it keeps the flip if a function f(KbT, delta_E) is
                         *less than a certain probability (0,1).
                         */
                        if(drand48() >= exp((-1) * (1.0/KbT) * changeInEnergy))
                        {
                            
                            //resets spin
                            lattice[i][j][k][z].reset();
                            successfulFlips -= 1;
                        }
                        else
                        {
                            //Keeps Spin flip if rand < exp()
                        }
                    }
                    else if(changeInEnergy == 0 && initialEnergy == 0)
                    {
                        //resets spin
                        lattice[i][j][k][z].reset();
                        successfulFlips -= 1;
                    }
                }
            }
        }
    }
}

bool MonteCarlo::thermalize(double KbT_){
    
    //Makes the lat Chars = 0
    double initKbT = KbT;
    KbT = KbT_;
    setCharsToZero();
    for(int i = 0; i < 10; i++){//Just a couple of runs to get started
        metropolisSweep();
        adjustRange();
    }
    
    //Thermalization
    for(int sweeps = 1; sweeps <= (4 * 1000 * 1000); sweeps++){
        metropolisSweep();
        adjustRange();
        if(isThermalized(sweeps)){
            cout << "finished thermalize successfully at: " << KbT;
            cout << " with " << sweeps << " many sweeps" << endl;
            KbT = initKbT;
            return true;
        }
    }
    
    cout << "finished thermalize UN_successfully at: " << KbT << endl;
    cerr << "finished thermalize UN_successfully at: " << KbT << endl;
    KbT = initKbT;
    return false;
}

bool MonteCarlo::isThermalized(int sweeps){
    
    double oldE = LC.sumE[0];
    double oldOP[NUMVECTORS][TYPESOP] = {0};
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            oldOP[i][j] = LC.sumOP[i][j][0];
        }
    }
    
    updateOrderParameters();
    
    LC.sumE[0] += OP.E;
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            LC.sumOP[i][j][0] += OP.charOP[i][j];
        }
    }
    
    double swp = 1.0 * sweeps;
    
    if(
       (fabs(LC.sumOP[0][0][0]/swp - oldOP[0][0]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[1][0][0]/swp - oldOP[1][0]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[5][0][0]/swp - oldOP[5][0]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[10][0][0]/swp - oldOP[10][0]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[0][3][0]/swp - oldOP[0][3]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[1][3][0]/swp - oldOP[1][3]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[5][3][0]/swp - oldOP[5][3]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[10][3][0]/swp - oldOP[10][3]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[0][6][0]/swp - oldOP[0][6]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[1][6][0]/swp - oldOP[1][6]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[5][6][0]/swp - oldOP[5][6]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumOP[10][6][0]/swp - oldOP[10][6]/(swp-1)) < 1e-7)&&
       (fabs(LC.sumE[0]/swp - oldE/(swp-1)) < 1e-7)
       ){
        setCharsToZero();
        
        return true;
    }
    
    return false;
}

void MonteCarlo::adjustRange(){
    
    double goal = 0.65;
    double successRate = successfulFlips / (flipAttempts * 1.0);
    double diff = successRate - goal;
    if(fabs(diff) < 0.01){
        return;
    }
    
    /**
     *This uses a binary search to change the range of the spin flips until
     *the rate of successful flips is ~goal.
     */
    double temp = fabs(range - rangeOld) / 2.0;
    if(temp == 0){temp = 0.1;}
    
    rangeOld = range;
    if(diff > 0){
        range += temp;
        if(range > PI){
            range = PI;
            return;
        }
    }else{
        range -= temp;
        if(range < 0.01){
            range = 0.01;
            return;
        }
    }
    successfulFlips = 0;
    flipAttempts = 0;
}

void MonteCarlo::updateOrderParameters(){   
    
    double E = 0;
    double TB = 0;
    double AB = 0;
    double X = 0;
    double Y = 0;
    double Z = 0;
    double XY = 0;
    double YZ = 0;
    double ZX = 0;
    double PX = 0;
    double PY = 0;
    double PZ = 0;
    double M[SPINDIMEN] = {0};
    double N[SPINDIMEN] = {0};
    double S1[SPINDIMEN] = {0};
    double S2[SPINDIMEN] = {0};
    double S3[SPINDIMEN] = {0};
    double N3D[SPINDIMEN] = {0};
    double ZZ1[SPINDIMEN] = {0};
    double ZZ2[SPINDIMEN] = {0};
    double ZZ3[SPINDIMEN] = {0};
    
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    
                    X = lattice[i][j][k][z].getX();
                    Y = lattice[i][j][k][z].getY();
                    Z = lattice[i][j][k][z].getZ();
                    XY = X * Y;
                    YZ = Y * Z;
                    ZX = Z * X;
                    PX = sqrt(2) * 0.5 * (2 * XY - YZ - ZX);
                    PY = sqrt(6) * 0.5 * (YZ - ZX);
                    PZ = XY + YZ + ZX;
                    
                    //OP: E
                    if(k < 1){//only sublattice 0 to not double count
                        if(z % 2 == 0){
                            E += getLocalEnergy(lattice[i][j][0][z]);
                        }else if (z % 2 == 1){
                            E += getLocalEnergy(lattice[i][j][1][z]);
                        }else{
                            std::cerr << "Shouldn't occur" << std::endl;
                            exit(1);
                        }
                    }
                    //End OP: E
                    
                    //OP: M
                    M[0] += X;
                    M[1] += Y;
                    M[2] += Z;
                    M[3] += XY;
                    M[4] += YZ;
                    M[5] += ZX;
                    M[6] += PX;
                    M[7] += PY;
                    M[8] += PZ;
                    //End OP: M
                    
                    //OP: N
                    //if k == 0 - count negative M, k == 1 - positive M
                    N[0] += (2 * k - 1) * X;
                    N[1] += (2 * k - 1) * Y;
                    N[2] += (2 * k - 1) * Z;
                    N[3] += (2 * k - 1) * XY;
                    N[4] += (2 * k - 1) * YZ;
                    N[5] += (2 * k - 1) * ZX;
                    N[6] += (2 * k - 1) * PX;
                    N[7] += (2 * k - 1) * PY;
                    N[8] += (2 * k - 1) * PZ;
                    //End OP: N
                    
                    //OP: S1
                    //along perp-y axis (ferro exchange along y direction)
                    if((i % 2 == 0) && (j % 2 == 0) && (k == 1)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        S1[3] += XY;
                        S1[4] += YZ;
                        S1[5] += ZX;
                        S1[6] += PX;
                        S1[7] += PY;
                        S1[8] += PZ;
                    }else if((i % 2 == 1) && (j % 2 == 1) && (k == 1)){ 
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        S1[3] += XY;
                        S1[4] += YZ;
                        S1[5] += ZX;
                        S1[6] += PX;
                        S1[7] += PY;
                        S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 1) && (k == 1)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        S1[3] += (-1) * XY;
                        S1[4] += (-1) * YZ;
                        S1[5] += (-1) * ZX;
                        S1[6] += (-1) * PX;
                        S1[7] += (-1) * PY;
                        S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 0) && (k == 1)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        S1[3] += (-1) * XY;
                        S1[4] += (-1) * YZ;
                        S1[5] += (-1) * ZX;
                        S1[6] += (-1) * PX;
                        S1[7] += (-1) * PY;
                        S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 0) && (k == 0)){    
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        S1[3] += XY;
                        S1[4] += YZ;
                        S1[5] += ZX;
                        S1[6] += PX;
                        S1[7] += PY;
                        S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 1) && (k == 0)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        S1[3] += XY;
                        S1[4] += YZ;
                        S1[5] += ZX;
                        S1[6] += PX;
                        S1[7] += PY;
                        S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 0) && (k == 0)){               
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        S1[3] += (-1) * XY;
                        S1[4] += (-1) * YZ;
                        S1[5] += (-1) * ZX;
                        S1[6] += (-1) * PX;
                        S1[7] += (-1) * PY;
                        S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 1) && (k == 0)){                 
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        S1[3] += (-1) * XY;
                        S1[4] += (-1) * YZ;
                        S1[5] += (-1) * ZX;
                        S1[6] += (-1) * PX;
                        S1[7] += (-1) * PY;
                        S1[8] += (-1) * PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S1
                    
                    //OP: S2
                    //along y axis (ferro exchange along x direction)
                    if((i % 2 == 0) && (k == 1)){           
                        S2[0] += X;
                        S2[1] += Y;
                        S2[2] += Z;
                        S2[3] += XY;
                        S2[4] += YZ;
                        S2[5] += ZX;
                        S2[6] += PX;
                        S2[7] += PY;
                        S2[8] += PZ;
                    }else if((i % 2 == 1) && (k == 1)){      
                        S2[0] += (-1) * X;
                        S2[1] += (-1) * Y;
                        S2[2] += (-1) * Z;
                        S2[3] += (-1) * XY;
                        S2[4] += (-1) * YZ;
                        S2[5] += (-1) * ZX;
                        S2[6] += (-1) * PX;
                        S2[7] += (-1) * PY;
                        S2[8] += (-1) * PZ;
                    }else if((i % 2 == 0) && (k == 0)){
                        S2[0] += (-1) * X;
                        S2[1] += (-1) * Y;
                        S2[2] += (-1) * Z;
                        S2[3] += (-1) * XY;
                        S2[4] += (-1) * YZ;
                        S2[5] += (-1) * ZX;
                        S2[6] += (-1) * PX;
                        S2[7] += (-1) * PY;
                        S2[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (k == 0)){
                        S2[0] += X;  
                        S2[1] += Y;  
                        S2[2] += Z; 
                        S2[3] += XY;
                        S2[4] += YZ;
                        S2[5] += ZX;
                        S2[6] += PX;
                        S2[7] += PY;
                        S2[8] += PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S2
                    
                    //OP: S3
                    //along x axis (ferro exchange along z direction)
                    if(j % 2 == 0){                      
                        S3[0] += X;
                        S3[1] += Y;
                        S3[2] += Z;
                        S3[3] += XY;
                        S3[4] += YZ;
                        S3[5] += ZX;
                        S3[6] += PX;
                        S3[7] += PY;
                        S3[8] += PZ;
                    }else if(j % 2 == 1){
                        S3[0] += (-1) * X;
                        S3[1] += (-1) * Y;
                        S3[2] += (-1) * Z;
                        S3[3] += (-1) * XY;
                        S3[4] += (-1) * YZ;
                        S3[5] += (-1) * ZX;
                        S3[6] += (-1) * PX;
                        S3[7] += (-1) * PY;
                        S3[8] += (-1) * PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S3
                    
                    //OP: N3D
                    //if k == 0 - count negative M, k == 1 - positive M
                    if(z % 2 == 0){
                        N3D[0] += (2 * k - 1) * X;
                        N3D[1] += (2 * k - 1) * Y;
                        N3D[2] += (2 * k - 1) * Z;
                        N3D[3] += (2 * k - 1) * XY;
                        N3D[4] += (2 * k - 1) * YZ;
                        N3D[5] += (2 * k - 1) * ZX;
                        N3D[6] += (2 * k - 1) * PX;
                        N3D[7] += (2 * k - 1) * PY;
                        N3D[8] += (2 * k - 1) * PZ;
                    }else if(z % 2 == 1){
                        //Alternatively vertically, count negative M.
                        N3D[0] += (-1) * (2 * k - 1) * X;
                        N3D[1] += (-1) * (2 * k - 1) * Y;
                        N3D[2] += (-1) * (2 * k - 1) * Z;
                        N3D[3] += (-1) * (2 * k - 1) * XY;
                        N3D[4] += (-1) * (2 * k - 1) * YZ;
                        N3D[5] += (-1) * (2 * k - 1) * ZX;
                        N3D[6] += (-1) * (2 * k - 1) * PX;
                        N3D[7] += (-1) * (2 * k - 1) * PY;
                        N3D[8] += (-1) * (2 * k - 1) * PZ;
                    }else{
                        cerr << "shouldn't happen" << endl;
                        exit(3161990);
                    }
                    //End OP: N3D
                    
                    //OP: ZZ1 (Zig Zag) along x axis
                    if((j % 2 == 0) && (k == 1)){
                        ZZ1[0] += X;
                        ZZ1[1] += Y;
                        ZZ1[2] += Z;
                        ZZ1[3] += XY;
                        ZZ1[4] += YZ;
                        ZZ1[5] += ZX;
                        ZZ1[6] += PX;
                        ZZ1[7] += PY;
                        ZZ1[8] += PZ;
                    }else if((j % 2 == 1) && (k == 1)){
                        ZZ1[0] += (-1) * X;
                        ZZ1[1] += (-1) * Y;
                        ZZ1[2] += (-1) * Z;
                        ZZ1[3] += (-1) * XY;
                        ZZ1[4] += (-1) * YZ;
                        ZZ1[5] += (-1) * ZX;
                        ZZ1[6] += (-1) * PX;
                        ZZ1[7] += (-1) * PY;
                        ZZ1[8] += (-1) * PZ;
                    }else if((j % 2 == 0) && (k == 0)){
                        ZZ1[0] += (-1) * X;
                        ZZ1[1] += (-1) * Y;
                        ZZ1[2] += (-1) * Z;
                        ZZ1[3] += (-1) * XY;
                        ZZ1[4] += (-1) * YZ;
                        ZZ1[5] += (-1) * ZX;
                        ZZ1[6] += (-1) * PX;
                        ZZ1[7] += (-1) * PY;
                        ZZ1[8] += (-1) * PZ;
                    }else if((j % 2 == 1) && (k == 0)){
                        ZZ1[0] += X;
                        ZZ1[1] += Y;
                        ZZ1[2] += Z;
                        ZZ1[3] += XY;
                        ZZ1[4] += YZ;
                        ZZ1[5] += ZX;
                        ZZ1[6] += PX;
                        ZZ1[7] += PY;
                        ZZ1[8] += PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ1
                    
                    //OP: ZZ2 (Zig Zag) - along Y axis
                    if((i % 2 == 0))
                    {
                        ZZ2[0] += (-1) * X;
                        ZZ2[1] += (-1) * Y;
                        ZZ2[2] += (-1) * Z;
                        ZZ2[3] += (-1) * XY;
                        ZZ2[4] += (-1) * YZ;
                        ZZ2[5] += (-1) * ZX;
                        ZZ2[6] += (-1) * PX;
                        ZZ2[7] += (-1) * PY;
                        ZZ2[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1))
                    {
                        ZZ2[0] += X;
                        ZZ2[1] += Y;
                        ZZ2[2] += Z;
                        ZZ2[3] += XY;
                        ZZ2[4] += YZ;
                        ZZ2[5] += ZX;
                        ZZ2[6] += PX;
                        ZZ2[7] += PY;
                        ZZ2[8] += PZ;
                    }
                    else
                    {
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ2
                    
                    //OP: ZZ3 (Zig Zag) - perp to y axis (along 
                    if((i % 2 == 0) && (j % 2 == 0))
                    {
                        ZZ3[0] += X;
                        ZZ3[1] += Y;
                        ZZ3[2] += Z;
                        ZZ3[3] += XY;
                        ZZ3[4] += YZ;
                        ZZ3[5] += ZX;
                        ZZ3[6] += PX;
                        ZZ3[7] += PY;
                        ZZ3[8] += PZ;
                    }
                    else if((i % 2 == 0) && (j % 2 == 1))
                    {
                        ZZ3[0] += (-1) * X;
                        ZZ3[1] += (-1) * Y;
                        ZZ3[2] += (-1) * Z;
                        ZZ3[3] += (-1) * XY;
                        ZZ3[4] += (-1) * YZ;
                        ZZ3[5] += (-1) * ZX;
                        ZZ3[6] += (-1) * PX;
                        ZZ3[7] += (-1) * PY;
                        ZZ3[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1) && (j % 2 == 0))
                    {
                        ZZ3[0] += (-1) * X;
                        ZZ3[1] += (-1) * Y;
                        ZZ3[2] += (-1) * Z;
                        ZZ3[3] += (-1) * XY;
                        ZZ3[4] += (-1) * YZ;
                        ZZ3[5] += (-1) * ZX;
                        ZZ3[6] += (-1) * PX;
                        ZZ3[7] += (-1) * PY;
                        ZZ3[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1) && (j % 2 == 1))
                    {
                        ZZ3[0] += X;
                        ZZ3[1] += Y;
                        ZZ3[2] += Z;
                        ZZ3[3] += XY;
                        ZZ3[4] += YZ;
                        ZZ3[5] += ZX;
                        ZZ3[6] += PX;
                        ZZ3[7] += PY;
                        ZZ3[8] += PZ;
                    }
                    else
                    {
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ3
                    
                    //OP: TB, Polar Angle to B Field
                    TB += getPolarAngleTB(X, Y, Z);
                    //End OP TB
                    
                    //OP: AB, Azimuthal Angle to the B Field
                    AB += getAziAngleAB(X, Y, Z);
                    //End OP: AB
                    
                }
            }
        }
    }
    //End OP
        
    OP.TB = TB;
    OP.AB = AB;
    OP.E = E; //Total E, E not per site
    
    //All Order parameters are per site
    double numSites = cellsA * cellsB * cellsC * 2.0;
    
    for(int i = 0; i < SPINDIMEN; i++){
        M[i] = M[i] / numSites;
        N[i] = N[i] / numSites;
        S1[i] = S1[i] / numSites;
        S2[i] = S2[i] / numSites;
        S3[i] = S3[i] / numSites;
        N3D[i] = N3D[i] / numSites;
        ZZ1[i] = ZZ1[i] / numSites;
        ZZ2[i] = ZZ2[i] / numSites;
        ZZ3[i] = ZZ3[i] / numSites;
    }
    OP.TB = OP.TB / numSites;
    OP.AB = OP.AB / numSites;
    
    //Now to calculate the characteristics of the order parameters.
    double OPArr[NUMVECTORS][SPINDIMEN] = {0};
    for(int i = 0; i < SPINDIMEN; i++){
        OPArr[0][i] = M[i];
        OPArr[1][i] = N[i];
        OPArr[2][i] = S1[i];
        OPArr[3][i] = S2[i];
        OPArr[4][i] = S3[i];
        OPArr[5][i] = sqrt(S1[i]*S1[i] + S2[i]*S2[i] + S3[i]*S3[i]);
        OPArr[6][i] = N3D[i];
        OPArr[7][i] = ZZ1[i];
        OPArr[8][i] = ZZ2[i];
        OPArr[9][i] = ZZ3[i];
        OPArr[10][i] = sqrt(ZZ1[i]*ZZ1[i] + ZZ2[i]*ZZ2[i] + ZZ3[i]*ZZ3[i]);
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        
        double a1 = 0;
        double a2 = PI/3.0;
        double a3 = 2*PI/3.0;
        double a4 = PI;
        double a5 = 4*PI/3.0;
        double a6 = 5*PI/3.0;
        
        //Scalar quantity eg. M
        OP.charOP[i][0] = sqrt(OPArr[i][0]*OPArr[i][0] +
                               OPArr[i][1]*OPArr[i][1] +
                               OPArr[i][2]*OPArr[i][2]);
        
        /*
         double tempB1 = (OP.snapOP[i][0]*OP.snapOP[i][0] +
         OP.snapOP[i][1]*OP.snapOP[i][1] -
         2*OP.snapOP[i][2]*OP.snapOP[i][2])/sqrt(6.0);
         
         double tempB2 = (OP.snapOP[i][0]*OP.snapOP[i][0] -
         OP.snapOP[i][1]*OP.snapOP[i][1])/sqrt(2.0);
         */
        
        double tempB1 = 0;
        double tempB2 = 0;
        
        tempB1 += fabs(OPArr[i][0])*cos(a1);
        tempB2 += fabs(OPArr[i][0])*sin(a1);
        
        tempB1 += fabs(OPArr[i][1])*cos(a3);
        tempB2 += fabs(OPArr[i][1])*sin(a3);
        
        tempB1 += fabs(OPArr[i][2])*cos(a5);
        tempB2 += fabs(OPArr[i][2])*sin(a5);
        
        //b1
        OP.charOP[i][1] = tempB1;
        
        //b2
        OP.charOP[i][2] = tempB2;
        
        //sqrt(b1*b1 + b2*b2)
        OP.charOP[i][3] = sqrt(OP.charOP[i][1]*OP.charOP[i][1] + 
                               OP.charOP[i][2]*OP.charOP[i][2]);
        
        //m
        double tempM1 = 0;
        double tempM2 = 0;
        
        if(OPArr[i][0] > 0){
            tempM1 += fabs(OPArr[i][0])*cos(a2);
            tempM2 += fabs(OPArr[i][0])*sin(a2);
        }else{
            tempM1 += fabs(OPArr[i][0])*cos(a5);
            tempM2 += fabs(OPArr[i][0])*sin(a5);
        }
        
        if(OPArr[i][1] > 0){
            tempM1 += fabs(OPArr[i][1])*cos(a1);
            tempM2 += fabs(OPArr[i][1])*sin(a1);
        }else{
            tempM1 += fabs(OPArr[i][1])*cos(a4);
            tempM2 += fabs(OPArr[i][1])*sin(a4);
        }
        
        if(OPArr[i][2] > 0){
            tempM1 += fabs(OPArr[i][2])*cos(a6);
            tempM2 += fabs(OPArr[i][2])*sin(a6);
        }else{
            tempM1 += fabs(OPArr[i][2])*cos(a3);
            tempM2 += fabs(OPArr[i][2])*sin(a3);
        }
        
        //m1
        OP.charOP[i][4] = tempM1;
        
        //m2
        OP.charOP[i][5] = tempM2;
        
        //sqrt(m1*m1 + m2*m2)
        OP.charOP[i][6] = sqrt(OP.charOP[i][4]*OP.charOP[i][4] + 
                               OP.charOP[i][5]*OP.charOP[i][5]);
        
        OP.charOP[i][7] = OPArr[i][0];
        
        OP.charOP[i][8] = OPArr[i][1];
        
        OP.charOP[i][9] = OPArr[i][2];
        
        OP.charOP[i][10] = OPArr[i][3];
        
        OP.charOP[i][11] = OPArr[i][4];
        
        OP.charOP[i][12] = OPArr[i][5];
        
        OP.charOP[i][13] = OPArr[i][6];
        
        OP.charOP[i][14] = OPArr[i][7];
        
        OP.charOP[i][15] = OPArr[i][8];
        
        OP.charOP[i][16] = sqrt(OPArr[i][6] * OPArr[i][6] +
                                OPArr[i][7] * OPArr[i][7] +
                                OPArr[i][8] * OPArr[i][8]);
        
        
    }
    
    
    updateCorrelationFunction();
    
}

void MonteCarlo::updateCorrelationFunction(){
    
    double E[NUMCORRSPINSBIG] = {0};
    double TB[NUMCORRSPINSBIG] = {0};
    double AB[NUMCORRSPINSBIG] = {0};
    double X = 0;
    double Y = 0;
    double Z = 0;
    double XY = 0;
    double YZ = 0;
    double ZX = 0;
    double PX = 0;
    double PY = 0;
    double PZ = 0;
    double M[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double N[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S1[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S2[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S3[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double N3D[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ1[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ2[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ3[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    
    int j = -1;//To start on zero for count = 0.
    int i = 0;
    int k = 0;
    int z = 0;
    
    for(int count = 0; count < 2*cellsA; count++){
        
        //This control structure picks the diagonal spins out across the lattice.
        if(count % 2 == 0 ){
            k = 0;
        }else{
            k = 1;
        }
        
        if(count % 4 == 0 ){
            i = i + 0;
        }else if(count % 4 == 1 ){
            i = i + 0;
        }else if(count % 4 == 2 ){
            i = i + 0;
        }else{
            i = i + 1;
        }
        
        if(count % 4 == 0 ){
            j = j + 1;
        }else if(count % 4 == 1 ){
            j = j + 0;
        }else if(count % 4 == 2 ){
            j = j + 1;
        }else{
            j = j - 1;
        }
        
        z = 0;
        
        //OP: E
        if(z % 2 == 0){
            E[count] = getLocalEnergy(lattice[i][j][0][z]);
        }else if (z % 2 == 1){
            E[count] = getLocalEnergy(lattice[i][j][1][z]);
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: E
        
        
        X = lattice[i][j][k][z].getX();
        Y = lattice[i][j][k][z].getY();
        Z = lattice[i][j][k][z].getZ();
        XY = X * Y;
        YZ = Y * Z;
        ZX = Z * X;
        PX = sqrt(2) * 0.5 * (2 * XY - YZ - ZX);
        PY = sqrt(6) * 0.5 * (YZ - ZX);
        PZ = XY + YZ + ZX;
        
        //OP: M
        M[0][count] += X;
        M[1][count] += Y;
        M[2][count] += Z;
        M[3][count] += XY;
        M[4][count] += YZ;
        M[5][count] += ZX;
        M[6][count] += PX;
        M[7][count] += PY;
        M[8][count] += PZ;
        //End OP: M
        
        //OP: N
        //if k == 0 - count negative M, k == 1 - positive M
        N[0][count] += (2 * k - 1) * X;
        N[1][count] += (2 * k - 1) * Y;
        N[2][count] += (2 * k - 1) * Z;
        N[3][count] += (2 * k - 1) * XY;
        N[4][count] += (2 * k - 1) * YZ;
        N[5][count] += (2 * k - 1) * ZX;
        N[6][count] += (2 * k - 1) * PX;
        N[7][count] += (2 * k - 1) * PY;
        N[8][count] += (2 * k - 1) * PZ;
        //End OP: N
        
        //OP: S1
        //along perp-y axis (ferro exchange along y direction)
        if((i % 2 == 0) && (j % 2 == 0) && (k == 1)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            S1[3][count] += XY;
            S1[4][count] += YZ;
            S1[5][count] += ZX;
            S1[6][count] += PX;
            S1[7][count] += PY;
            S1[8][count] += PZ;
        }else if((i % 2 == 1) && (j % 2 == 1) && (k == 1)){ 
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            S1[3][count] += XY;
            S1[4][count] += YZ;
            S1[5][count] += ZX;
            S1[6][count] += PX;
            S1[7][count] += PY;
            S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 1) && (k == 1)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            S1[3][count] += (-1) * XY;
            S1[4][count] += (-1) * YZ;
            S1[5][count] += (-1) * ZX;
            S1[6][count] += (-1) * PX;
            S1[7][count] += (-1) * PY;
            S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 0) && (k == 1)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            S1[3][count] += (-1) * XY;
            S1[4][count] += (-1) * YZ;
            S1[5][count] += (-1) * ZX;
            S1[6][count] += (-1) * PX;
            S1[7][count] += (-1) * PY;
            S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 0) && (k == 0)){    
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            S1[3][count] += XY;
            S1[4][count] += YZ;
            S1[5][count] += ZX;
            S1[6][count] += PX;
            S1[7][count] += PY;
            S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 1) && (k == 0)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            S1[3][count] += XY;
            S1[4][count] += YZ;
            S1[5][count] += ZX;
            S1[6][count] += PX;
            S1[7][count] += PY;
            S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 0) && (k == 0)){               
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            S1[3][count] += (-1) * XY;
            S1[4][count] += (-1) * YZ;
            S1[5][count] += (-1) * ZX;
            S1[6][count] += (-1) * PX;
            S1[7][count] += (-1) * PY;
            S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 1) && (k == 0)){                 
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            S1[3][count] += (-1) * XY;
            S1[4][count] += (-1) * YZ;
            S1[5][count] += (-1) * ZX;
            S1[6][count] += (-1) * PX;
            S1[7][count] += (-1) * PY;
            S1[8][count] += (-1) * PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S1
        
        //OP: S2
        //along y axis (ferro exchange along x direction)
        if((i % 2 == 0) && (k == 1)){           
            S2[0][count] += X;
            S2[1][count] += Y;
            S2[2][count] += Z;
            S2[3][count] += XY;
            S2[4][count] += YZ;
            S2[5][count] += ZX;
            S2[6][count] += PX;
            S2[7][count] += PY;
            S2[8][count] += PZ;
        }else if((i % 2 == 1) && (k == 1)){      
            S2[0][count] += (-1) * X;
            S2[1][count] += (-1) * Y;
            S2[2][count] += (-1) * Z;
            S2[3][count] += (-1) * XY;
            S2[4][count] += (-1) * YZ;
            S2[5][count] += (-1) * ZX;
            S2[6][count] += (-1) * PX;
            S2[7][count] += (-1) * PY;
            S2[8][count] += (-1) * PZ;
        }else if((i % 2 == 0) && (k == 0)){
            S2[0][count] += (-1) * X;
            S2[1][count] += (-1) * Y;
            S2[2][count] += (-1) * Z;
            S2[3][count] += (-1) * XY;
            S2[4][count] += (-1) * YZ;
            S2[5][count] += (-1) * ZX;
            S2[6][count] += (-1) * PX;
            S2[7][count] += (-1) * PY;
            S2[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (k == 0)){
            S2[0][count] += X;  
            S2[1][count] += Y;  
            S2[2][count] += Z; 
            S2[3][count] += XY;
            S2[4][count] += YZ;
            S2[5][count] += ZX;
            S2[6][count] += PX;
            S2[7][count] += PY;
            S2[8][count] += PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S2
        
        //OP: S3
        //along x axis (ferro exchange along z direction)
        if(j % 2 == 0){                      
            S3[0][count] += X;
            S3[1][count] += Y;
            S3[2][count] += Z;
            S3[3][count] += XY;
            S3[4][count] += YZ;
            S3[5][count] += ZX;
            S3[6][count] += PX;
            S3[7][count] += PY;
            S3[8][count] += PZ;
        }else if(j % 2 == 1){
            S3[0][count] += (-1) * X;
            S3[1][count] += (-1) * Y;
            S3[2][count] += (-1) * Z;
            S3[3][count] += (-1) * XY;
            S3[4][count] += (-1) * YZ;
            S3[5][count] += (-1) * ZX;
            S3[6][count] += (-1) * PX;
            S3[7][count] += (-1) * PY;
            S3[8][count] += (-1) * PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S3
        
        //OP: N3D
        //if k == 0 - count negative M, k == 1 - positive M
        if(z % 2 == 0){
            N3D[0][count] += (2 * k - 1) * X;
            N3D[1][count] += (2 * k - 1) * Y;
            N3D[2][count] += (2 * k - 1) * Z;
            N3D[3][count] += (2 * k - 1) * XY;
            N3D[4][count] += (2 * k - 1) * YZ;
            N3D[5][count] += (2 * k - 1) * ZX;
            N3D[6][count] += (2 * k - 1) * PX;
            N3D[7][count] += (2 * k - 1) * PY;
            N3D[8][count] += (2 * k - 1) * PZ;
        }else if(z % 2 == 1){
            //Alternatively vertically, count negative M.
            N3D[0][count] += (-1) * (2 * k - 1) * X;
            N3D[1][count] += (-1) * (2 * k - 1) * Y;
            N3D[2][count] += (-1) * (2 * k - 1) * Z;
            N3D[3][count] += (-1) * (2 * k - 1) * XY;
            N3D[4][count] += (-1) * (2 * k - 1) * YZ;
            N3D[5][count] += (-1) * (2 * k - 1) * ZX;
            N3D[6][count] += (-1) * (2 * k - 1) * PX;
            N3D[7][count] += (-1) * (2 * k - 1) * PY;
            N3D[8][count] += (-1) * (2 * k - 1) * PZ;
        }else{
            cerr << "shouldn't happen" << endl;
            exit(3161990);
        }
        //End OP: N3D
        
        //OP: ZZ1 (Zig Zag) along x axis
        if((j % 2 == 0) && (k == 1)){
            ZZ1[0][count] += X;
            ZZ1[1][count] += Y;
            ZZ1[2][count] += Z;
            ZZ1[3][count] += XY;
            ZZ1[4][count] += YZ;
            ZZ1[5][count] += ZX;
            ZZ1[6][count] += PX;
            ZZ1[7][count] += PY;
            ZZ1[8][count] += PZ;
        }else if((j % 2 == 1) && (k == 1)){
            ZZ1[0][count] += (-1) * X;
            ZZ1[1][count] += (-1) * Y;
            ZZ1[2][count] += (-1) * Z;
            ZZ1[3][count] += (-1) * XY;
            ZZ1[4][count] += (-1) * YZ;
            ZZ1[5][count] += (-1) * ZX;
            ZZ1[6][count] += (-1) * PX;
            ZZ1[7][count] += (-1) * PY;
            ZZ1[8][count] += (-1) * PZ;
        }else if((j % 2 == 0) && (k == 0)){
            ZZ1[0][count] += (-1) * X;
            ZZ1[1][count] += (-1) * Y;
            ZZ1[2][count] += (-1) * Z;
            ZZ1[3][count] += (-1) * XY;
            ZZ1[4][count] += (-1) * YZ;
            ZZ1[5][count] += (-1) * ZX;
            ZZ1[6][count] += (-1) * PX;
            ZZ1[7][count] += (-1) * PY;
            ZZ1[8][count] += (-1) * PZ;
        }else if((j % 2 == 1) && (k == 0)){
            ZZ1[0][count] += X;
            ZZ1[1][count] += Y;
            ZZ1[2][count] += Z;
            ZZ1[3][count] += XY;
            ZZ1[4][count] += YZ;
            ZZ1[5][count] += ZX;
            ZZ1[6][count] += PX;
            ZZ1[7][count] += PY;
            ZZ1[8][count] += PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ1
        
        //OP: ZZ2 (Zig Zag) - along Y axis
        if((i % 2 == 0))
        {
            ZZ2[0][count] += (-1) * X;
            ZZ2[1][count] += (-1) * Y;
            ZZ2[2][count] += (-1) * Z;
            ZZ2[3][count] += (-1) * XY;
            ZZ2[4][count] += (-1) * YZ;
            ZZ2[5][count] += (-1) * ZX;
            ZZ2[6][count] += (-1) * PX;
            ZZ2[7][count] += (-1) * PY;
            ZZ2[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1))
        {
            ZZ2[0][count] += X;
            ZZ2[1][count] += Y;
            ZZ2[2][count] += Z;
            ZZ2[3][count] += XY;
            ZZ2[4][count] += YZ;
            ZZ2[5][count] += ZX;
            ZZ2[6][count] += PX;
            ZZ2[7][count] += PY;
            ZZ2[8][count] += PZ;
        }
        else
        {
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ2
        
        //OP: ZZ3 (Zig Zag) - perp to y axis (along 
        if((i % 2 == 0) && (j % 2 == 0))
        {
            ZZ3[0][count] += X;
            ZZ3[1][count] += Y;
            ZZ3[2][count] += Z;
            ZZ3[3][count] += XY;
            ZZ3[4][count] += YZ;
            ZZ3[5][count] += ZX;
            ZZ3[6][count] += PX;
            ZZ3[7][count] += PY;
            ZZ3[8][count] += PZ;
        }
        else if((i % 2 == 0) && (j % 2 == 1))
        {
            ZZ3[0][count] += (-1) * X;
            ZZ3[1][count] += (-1) * Y;
            ZZ3[2][count] += (-1) * Z;
            ZZ3[3][count] += (-1) * XY;
            ZZ3[4][count] += (-1) * YZ;
            ZZ3[5][count] += (-1) * ZX;
            ZZ3[6][count] += (-1) * PX;
            ZZ3[7][count] += (-1) * PY;
            ZZ3[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1) && (j % 2 == 0))
        {
            ZZ3[0][count] += (-1) * X;
            ZZ3[1][count] += (-1) * Y;
            ZZ3[2][count] += (-1) * Z;
            ZZ3[3][count] += (-1) * XY;
            ZZ3[4][count] += (-1) * YZ;
            ZZ3[5][count] += (-1) * ZX;
            ZZ3[6][count] += (-1) * PX;
            ZZ3[7][count] += (-1) * PY;
            ZZ3[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1) && (j % 2 == 1))
        {
            ZZ3[0][count] += X;
            ZZ3[1][count] += Y;
            ZZ3[2][count] += Z;
            ZZ3[3][count] += XY;
            ZZ3[4][count] += YZ;
            ZZ3[5][count] += ZX;
            ZZ3[6][count] += PX;
            ZZ3[7][count] += PY;
            ZZ3[8][count] += PZ;
        }
        else
        {
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ3  
        
        //OP: TB
        TB[count] = getPolarAngleTB(X,Y,Z);
        //End OP: TB
        
        //OP: AB
        AB[count] = getAziAngleAB(X,Y,Z);
        //End OP: AB
        
    }
    

    double OPArr[NUMVECTORS][SPINDIMEN][NUMCORRSPINSBIG] = {0};
    const int DIMOFB = 2;
    double bOP[NUMVECTORS][DIMOFB][NUMCORRSPINSBIG] = {0};
    double mOP[NUMVECTORS][DIMOFB][NUMCORRSPINSBIG] = {0};
    
    for(int i = 0; i < SPINDIMEN; i++){
        for(int j = 0; j < 2*cellsA; j++){
            OPArr[0][i][j] = M[i][j];
            OPArr[1][i][j] = N[i][j];
            OPArr[2][i][j] = S1[i][j];
            OPArr[3][i][j] = S2[i][j];
            OPArr[4][i][j] = S3[i][j];
            OPArr[5][i][j] = sqrt(S1[i][j]*S1[i][j] +
                                   S2[i][j]*S2[i][j] +
                                   S3[i][j]*S3[i][j]);
            
            OPArr[6][i][j] = N3D[i][j];
            OPArr[7][i][j] = ZZ1[i][j];
            OPArr[8][i][j] = ZZ2[i][j];
            OPArr[9][i][j] = ZZ3[i][j];
            OPArr[10][i][j] = sqrt(ZZ1[i][j]*ZZ1[i][j] +
                                    ZZ2[i][j]*ZZ2[i][j] +
                                    ZZ3[i][j]*ZZ3[i][j]);
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int k = 0; k < 2*cellsA; k++){
            
            double a1 = 0;
            double a2 = PI/3.0;
            double a3 = 2*PI/3.0;
            double a4 = PI;
            double a5 = 4*PI/3.0;
            double a6 = 5*PI/3.0;
            
            /*
             double tempB1 = (snapOP[i][0]*snapOP[i][0] +
             snapOP[i][1]*snapOP[i][1] -
             2*snapOP[i][2]*snapOP[i][2])/sqrt(6.0);
             
             double tempB2 = (snapOP[i][0]*snapOP[i][0] -
             snapOP[i][1]*snapOP[i][1])/sqrt(2.0);
             */
            
            double tempB1 = 0;
            double tempB2 = 0;
            
            tempB1 += fabs(OPArr[i][0][k])*cos(a1);
            tempB2 += fabs(OPArr[i][0][k])*sin(a1);
            
            tempB1 += fabs(OPArr[i][1][k])*cos(a3);
            tempB2 += fabs(OPArr[i][1][k])*sin(a3);
            
            tempB1 += fabs(OPArr[i][2][k])*cos(a5);
            tempB2 += fabs(OPArr[i][2][k])*sin(a5);
            
            //b1, b2
            bOP[i][0][k] = tempB1;
            bOP[i][1][k] = tempB2;
            
            //m
            double tempM1 = 0;
            double tempM2 = 0;
            
            if(OPArr[i][0] > 0){
                tempM1 += fabs(OPArr[i][0][k])*cos(a2);
                tempM2 += fabs(OPArr[i][0][k])*sin(a2);
            }else{
                tempM1 += fabs(OPArr[i][0][k])*cos(a5);
                tempM2 += fabs(OPArr[i][0][k])*sin(a5);
            }
            
            if(OPArr[i][1] > 0){
                tempM1 += fabs(OPArr[i][1][k])*cos(a1);
                tempM2 += fabs(OPArr[i][1][k])*sin(a1);
            }else{
                tempM1 += fabs(OPArr[i][1][k])*cos(a4);
                tempM2 += fabs(OPArr[i][1][k])*sin(a4);
            }
            
            if(OPArr[i][2] > 0){
                tempM1 += fabs(OPArr[i][2][k])*cos(a6);
                tempM2 += fabs(OPArr[i][2][k])*sin(a6);
            }else{
                tempM1 += fabs(OPArr[i][2][k])*cos(a3);
                tempM2 += fabs(OPArr[i][2][k])*sin(a3);
            }
            
            //m1, m2
            mOP[i][0][k] = tempM1;
            mOP[i][1][k] = tempM2;
            
        }
    }
    
    //Calculate correlation function, dot products of spins
    for(int i = 0; i < NUMVECTORS; i++){
        
        //OP:
        for(int count = 0; count < 2*cellsA; count++){
            OP.corrFunc[i][0][count] = (OPArr[i][0][0] * OPArr[i][0][count] +
                                        OPArr[i][1][0] * OPArr[i][1][count] +
                                        OPArr[i][2][0] * OPArr[i][2][count]);
            
            //b OP:
            OP.corrFunc[i][1][count] = (bOP[i][0][0] * bOP[i][0][count]);
            
            OP.corrFunc[i][2][count] = (bOP[i][0][0] * bOP[i][0][count]);
            
            OP.corrFunc[i][3][count] = (bOP[i][0][0] * bOP[i][0][count] +
                                        bOP[i][1][0] * bOP[i][1][count]);
            
            //m OP:
            OP.corrFunc[i][4][count] = (mOP[i][0][0] * mOP[i][0][count]);
            
            OP.corrFunc[i][5][count] = (mOP[i][1][0] * mOP[i][1][count]);
            
            OP.corrFunc[i][6][count] = (mOP[i][0][0] * mOP[i][0][count] +
                                        mOP[i][1][0] * mOP[i][1][count]);
            
            //spin components
            OP.corrFunc[i][7][count] = OPArr[i][7][0] * OPArr[i][7][count];
            
            OP.corrFunc[i][8][count] = OPArr[i][8][0] * OPArr[i][8][count];
            
            OP.corrFunc[i][9][count] = OPArr[i][9][0] * OPArr[i][9][count];
            
            OP.corrFunc[i][10][count] = OPArr[i][10][0] * OPArr[i][10][count];
            
            OP.corrFunc[i][11][count] = OPArr[i][11][0] * OPArr[i][11][count];
            
            OP.corrFunc[i][12][count] = OPArr[i][12][0] * OPArr[i][12][count];
            
            OP.corrFunc[i][13][count] = OPArr[i][13][0] * OPArr[i][13][count];
            
            OP.corrFunc[i][14][count] = OPArr[i][14][0] * OPArr[i][14][count];
            
            OP.corrFunc[i][15][count] = OPArr[i][15][0] * OPArr[i][15][count];
            
            OP.corrFunc[i][16][count] = (OPArr[i][13][0] * OPArr[i][13][count] +
                                         OPArr[i][14][0] * OPArr[i][14][count] +
                                         OPArr[i][15][0] * OPArr[i][15][count]);
            
        }
    }
    
    for(int count = 0; count < 2*cellsA; count++){
        OP.ECorrFunc[count] = E[0] * E[count];
        OP.TBCorrFunc[count] = TB[0] * TB[count];
        OP.ABCorrFunc[count] = AB[0] * AB[count];
    }
    
    
};

void MonteCarlo::addToMagStats(){    
    
    updateOrderParameters();
    
    //E
    LC.sumE[0] += OP.E;
    LC.sumE[1] += OP.E*OP.E;
    LC.sumE[2] += (OP.E*OP.E) * OP.E;
    LC.sumE[3] += (OP.E*OP.E) * (OP.E*OP.E);
    
    //TB
    LC.sumTB[0] += OP.TB;
    LC.sumTB[1] += OP.TB*OP.TB;
    LC.sumTB[2] += (OP.TB*OP.TB) * OP.TB;
    LC.sumTB[3] += (OP.TB*OP.TB) * (OP.TB*OP.TB);
    
    //AB
    LC.sumAB[0] += OP.AB;
    LC.sumAB[1] += OP.AB*OP.AB;
    LC.sumAB[2] += (OP.AB*OP.AB) * OP.AB;
    LC.sumAB[3] += (OP.AB*OP.AB) * (OP.AB*OP.AB);
    
    double temp2 = 0;
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            
            temp2 = OP.charOP[i][j]*OP.charOP[i][j];
            
            LC.sumOP[i][j][0] += OP.charOP[i][j];
            LC.sumOP[i][j][1] += temp2;
            LC.sumOP[i][j][2] += OP.charOP[i][j]*temp2;
            LC.sumOP[i][j][3] += temp2*temp2;
        }
    }
    
    //Correlation Function
    for(int count = 0; count < 2*cellsA; count++){
        LC.sumECorrFunc[count] += OP.ECorrFunc[count];
    }
    for(int count = 0; count < 2*cellsA; count++){
        LC.sumTBCorrFunc[count] += OP.TBCorrFunc[count];
    }
    for(int count = 0; count < 2*cellsA; count++){
        LC.sumABCorrFunc[count] += OP.ABCorrFunc[count];
    }
    
    for(int count = 0; count < 2*cellsA; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                LC.sumOPCorrFunc[i][j][count] += OP.corrFunc[i][j][count];
            }
        }
    }
    
    configurations++;
    
    if(drand48() * 10000 < 1){
        adjustRange();
        doC2Rotation001();
    }
    
}

void MonteCarlo::sweep(int numSweeps_, int numIndep_, double hours_){
    
    clock_t start = clock();
    
    for(int sweeps = 1; sweeps <= numSweeps_; sweeps++)
    {
        metropolisSweep();
        if(sweeps % numIndep_ == 0){
            addToMagStats();
        }
        
        if((clock() - start) * (1/(CLOCKS_PER_SEC*1.0)) > (hours_*60*60) ){
            cout<<"Ran out of time, in sweep()"<<endl;
            break;
        }
    }
    
    finalPrint();
    cout<<"finished print(), in sweep()"<<endl;
    
}

void MonteCarlo::sweepSnapshot(int numSweeps_, int numIndep_, double hours_){
    
    clock_t start = clock();
    while((clock() - start) * (1/(CLOCKS_PER_SEC*1.0)) < (hours_*60*60) )
    {
        double KbT_ = KbT;
        thermalize(KbT_ * 64);
        thermalize(KbT_ * 16);
        thermalize(KbT_ * 4);
        thermalize(KbT_ * 2);
        thermalize(KbT_);
        int swept = 0;
        for(int sweeps = 1; sweeps <= numSweeps_; sweeps++)
        {
            metropolisSweep();
            if(sweeps % numIndep_ == 0)
            {
                printSnapshot();
            }
            
            if((clock() - start) * (1/(CLOCKS_PER_SEC*1.0)) > (hours_*60*60) ){
                swept = sweeps;
                break;
            }
            
        }
        
        //
        std::stringstream stream;
        std::ofstream fileOut;
        char path [512];
        getcwd(path, 512);
        
        stringstream out;
        out.str("");
        string temp = outputMag.substr(0,outputMag.size()-4);
        out << temp.c_str() << "OPSnap.txt";
        
        fileOut.open(out.str().c_str(), std::ios::out | std::ios::app);
        stream.str("");
        
        stream << "Done with one run of sweepSnapshot(), consisting of " << swept;
        stream << " runs, skipping every " << numIndep_ << " sweep." <<endl;
        
        fileOut << stream.str() << std::endl;
        fileOut.close();
        //
        
    }
    
    finalPrint();
    cout<<"finished finalPrint(), in sweepSnapshot()"<<endl;
    
}

void MonteCarlo::finalPrint(){
    
    updateOrderParameters();
    
    //Averaging.
    double aveE[POWERSOP] = {0};
    double aveTB[POWERSOP] = {0};
    double aveAB[POWERSOP] = {0};
    double aveOP[NUMVECTORS][TYPESOP][POWERSOP] = {0};
    
    //E
    aveE[0] = LC.sumE[0] / (configurations*1.0);
    aveE[1] = LC.sumE[1] / (configurations*1.0);
    aveE[2] = LC.sumE[2] / (configurations*1.0);
    aveE[3] = LC.sumE[3] / (configurations*1.0);
    //TB
    aveTB[0] = LC.sumTB[0] / (configurations*1.0);
    aveTB[1] = LC.sumTB[1] / (configurations*1.0);
    aveTB[2] = LC.sumTB[2] / (configurations*1.0);
    aveTB[3] = LC.sumTB[3] / (configurations*1.0);
    //AB
    aveAB[0] = LC.sumAB[0] / (configurations*1.0);
    aveAB[1] = LC.sumAB[1] / (configurations*1.0);
    aveAB[2] = LC.sumAB[2] / (configurations*1.0);
    aveAB[3] = LC.sumAB[3] / (configurations*1.0);
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                aveOP[i][j][k] = LC.sumOP[i][j][k] / (configurations*1.0);
            }
        }
    }
    
    //Correlation Function
    double aveECorr[NUMCORRSPINSBIG] = {0};
    double aveTBCorr[NUMCORRSPINSBIG] = {0};
    double aveABCorr[NUMCORRSPINSBIG] = {0};
    double aveOPCorr[NUMVECTORS][TYPESOP][NUMCORRSPINSBIG] = {0};
    
    for(int count = 0; count < 2*cellsA; count++){
        aveECorr[count] = LC.sumECorrFunc[count] / (configurations*1.0);
        aveTBCorr[count] = LC.sumTBCorrFunc[count] / (configurations*1.0);
        aveABCorr[count] = LC.sumABCorrFunc[count] / (configurations*1.0);
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                aveOPCorr[i][j][count] = LC.sumOPCorrFunc[i][j][count] / (configurations*1.0);
            }
        }
    }
    
    //Calculate Lattice Quantity
    double suscep[NUMVECTORS][TYPESOP] = {0};
    double binder[NUMVECTORS][TYPESOP] = {0};
    double spHeat = 0;
    
    double numSites = cellsA * cellsB * cellsC * 2.0;
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            suscep[i][j] = numSites*(aveOP[i][j][1] - aveOP[i][j][0]*aveOP[i][j][0])/KbT;
            binder[i][j] = 1.0 - aveOP[i][j][3]/(3.0*aveOP[i][j][1]*aveOP[i][j][1]);
        }
    }
    spHeat = (aveE[1] - (aveE[0]*aveE[0])) / (KbT*KbT*numSites);
    
    //Printing out info
    std::stringstream stream;
    std::ofstream fileOut;
    char path [512];
    getcwd(path, 512);
    time_t t = time(0);
    tm time = *localtime(&t);
    
    fileOut.open(outputMag.c_str(), std::ios::out | std::ios::trunc);
    if (!fileOut.is_open() || !fileOut.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    stream.str("");
    stream << "Start characteristics for this configuration" << endl;
    stream << "Time: " << std::setw(2) << std::setfill('0') <<
    time.tm_mon + 1 << "_" << std::setw(2) << std::setfill('0') <<
    time.tm_mday << "_" << time.tm_year + 1900 << "_" << time.tm_hour + 1 << endl;
    if((successfulFlips/flipAttempts) * 100 < 50){
        cerr << "Alert! acceptance rate is too low!" << endl;
        cerr << "Flip Success percentage: " << successfulFlips/flipAttempts<<endl;
        cerr << "Range: " << range <<endl;
        stream << "Alert! acceptance rate is too low!" << endl;
        stream << "Flip Success percentage: " << successfulFlips/flipAttempts<<endl;
        stream << "Range: " << range <<endl;
    }
    stream << "Cells-A: " << cellsA << endl;
    stream << "Cells-B: " << cellsB << endl;
    stream << "Cells-C: " << cellsC << endl;
    stream << "KbT: " << KbT << endl;
    stream << "Alpha: " << alpha << endl;
    stream << "External Magnetic Field: " << extMagField << endl;
    stream << "Parameter-1: " << param1 << endl;
    stream << "Parameter-2: " << param2 << endl;
    stream << "Configurations: " << configurations << endl;
    stream << "Flip Success percentage: " << successfulFlips/flipAttempts<<endl;
    stream << "Flip Range: " << range << endl;
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Current Snapshot, " << charOPNames[i][j] << ": ";
            stream << std::scientific << std::setprecision(PR) << OP.charOP[i][j] << endl;
        }
    }
    //E
    stream << "Current Snapshot, Energy: ";
    stream << std::scientific << std::setprecision(PR) << OP.E << endl;
    //TB
    stream << "Current Snapshot, Polar Angle to B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.TB << endl;
    //AB
    stream << "Current Snapshot, Azimuthal Angle to the B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.AB << endl;
    
    //Correlation function
    for(int count = 0; count < cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Current Snapshot, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << OP.corrFunc[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << OP.ECorrFunc[count] << endl;
    }
    //TB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << OP.TBCorrFunc[count] << endl;
    }
    //AB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << OP.ABCorrFunc[count] << endl;
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                stream << "Sum over Configurations, " << sumOPNames[i][j][k] << ": ";
                stream << std::scientific << std::setprecision(PR) << LC.sumOP[i][j][k] << endl;
            }
        }
    }
    //E
    stream << "Sum over Configurations, Energy to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[0] << endl;
    stream << "Sum over Configurations, Energy to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[1] << endl;
    stream << "Sum over Configurations, Energy to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[2] << endl;
    stream << "Sum over Configurations, Energy to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[3] << endl;
    //TB
    stream << "Sum over Configurations, Polar Angle to B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[0] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[1] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[2] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[3] << endl;
    //AB
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[0] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[1] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[2] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[3] << endl;
    
    //Correlation function
    for(int count = 0; count < cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Sum over Configurations, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << LC.sumOPCorrFunc[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << LC.sumECorrFunc[count] << endl;
    }
    //TB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << LC.sumTBCorrFunc[count] << endl;
    }
    //AB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << LC.sumABCorrFunc[count] << endl;
    }
    
    //Snapshot of M
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    stream << "Components of Spin " << i << "," << j << "," <<
                    z << "," << k << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getX() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getY() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getZ() << endl;
                }
            }
        }
    }    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, " << charOPNames[i][j] << ": " <<
            std::scientific << std::setprecision(PR) << aveOP[i][j][0] << endl;
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, Susceptibility - " << charOPNames[i][j] << ": "<<
            std::scientific << std::setprecision(PR) << suscep[i][j] << endl;
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, Binder - " << charOPNames[i][j] << ": "<<
            std::scientific << std::setprecision(PR) << binder[i][j] << endl;
        }
    }
    
    //Correlation function
    for(int count = 0; count < cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Lattice Averaged Quantity, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << aveOPCorr[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < cellsA*2; count++){
        stream << "Lattice Averaged Quantity, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << aveECorr[count] << endl;
    }
    //TB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Lattice Averaged Quantity, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << aveTBCorr[count] << endl;
    }
    //AB
    for(int count = 0; count < cellsA*2; count++){
        stream << "Lattice Averaged Quantity, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << aveABCorr[count] << endl;
    }
    
    //
    //E
    stream << "Lattice Averaged Quantity, Energy to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[0] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[1] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[2] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[3] << endl;
    //TB
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[0] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[1] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[2] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[3] << endl;
    //AB
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[0] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[1] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[2] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[3] << endl;
    //
    
    stream << "Specific Heat: ";
    stream << std::scientific << std::setprecision(PR) << spHeat << endl;
    stream << "Energy Per Site: " << std::scientific <<
    std::setprecision(PR) << aveE[0] / numSites << endl;
    stream << "End information for this configuration" << endl;
    stream << endl;
    fileOut << stream.str() << std::endl;
    //std::cout << stream.str() << std::endl;
    fileOut.close();
    //printDiagram();
    
}

void MonteCarlo::printSnapshot(){
    updateOrderParameters();
    
    std::stringstream stream;
    std::ofstream fileOut;
    char path [512];
    getcwd(path, 512);
    
    stringstream out;
    out.str("");
    string temp = outputMag.substr(0,outputMag.size()-4);
    out << temp.c_str() << "OPSnap.txt";
    
    fileOut.open(out.str().c_str(), std::ios::out | std::ios::app);
    stream.str("");
    
    /*
     for(int i = 0; i < NUMVECTORS; i++){
     for(int j = 0; j < SPINDIMEN; j++){
     stream << snapOPNamesSmall[i][j] << ": ";
     stream << std::scientific << std::setprecision(PR) << OP.snapOP[i][j] << endl;
     }
     }
     stream << "E: ";
     stream << std::scientific << std::setprecision(PR) << OP.E << endl;
     */
    
    double a1 = 0;
    double a2 = PI/3.0;
    double a3 = 2*PI/3.0;
    double a4 = PI;
    double a5 = 4*PI/3.0;
    double a6 = 5*PI/3.0;
    
    double m1 = 0;
    double m2 = 0;
    
    double N_X = OP.charOP[1][0];
    double N_Y = OP.charOP[1][1];
    double N_Z = OP.charOP[1][2];
    
    if(N_X > 0){m1 += fabs(N_X)*cos(a2); m2 += fabs(N_X)*sin(a2);}
    else       {m1 += fabs(N_X)*cos(a5); m2 += fabs(N_X)*sin(a5);}
    
    if(N_Y > 0){m1 += fabs(N_Y)*cos(a1); m2 += fabs(N_Y)*sin(a1);}
    else       {m1 += fabs(N_Y)*cos(a4); m2 += fabs(N_Y)*sin(a4);}
    
    if(N_Z > 0){m1 += fabs(N_Z)*cos(a6); m2 += fabs(N_Z)*sin(a6);}
    else       {m1 += fabs(N_Z)*cos(a3); m2 += fabs(N_Z)*sin(a3);}
    
    stream << "MN: " << std::scientific << std::setprecision(PR) << m1;
    stream << ", " << std::scientific << std::setprecision(PR) << m2 << endl;
    
    fileOut << stream.str() << std::endl;
    fileOut.close();
    
    
}

double MonteCarlo::getLocalEnergy(const ClassicalSpin3D& a) const{
    
    double interX = 1;
    double interY = 1;
    double interZ = 1;
    
    //Heisenberg interaction
    double interaction1X = a.dotProd(getSpinInTheXDir(a));
    double interaction1Y = a.dotProd(getSpinInTheYDir(a));
    double interaction1Z = a.dotProd(getSpinInTheZDir(a));
    
    //Normal rotated coords
    
    double interaction1 = cos(alpha) * (interaction1X + interaction1Y + interaction1Z);
    
    //Kitaev interaction
    
    double interaction2 = getSpinInTheXDir(a).getX() * a.getX() +
    getSpinInTheYDir(a).getY() * a.getY() +
    getSpinInTheZDir(a).getZ() * a.getZ();
    interaction2 = interaction2 * 2 * sin(alpha);
    
    
    //B field
    double interaction3 = (-1) * extMagField * 
    (COMPONENTOFBFIELDIN_X_DIRECTION * a.getX() +
     COMPONENTOFBFIELDIN_Y_DIRECTION * a.getY() +
     COMPONENTOFBFIELDIN_Z_DIRECTION * a.getZ());
    
    
    
    
    return interaction1 + interaction2 + interaction3;
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheXDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(a.getPosS() == 0){
        if((aX == cellsA - 1) && (aY == cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aX == cellsA - 1) && (aY == 0)){
            return lattice[aX][cellsB - 1][1][aZ];
        }else if((aX == 0) && (aY == cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX][cellsB - 1][1][aZ];
        }else if((aX == 0)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aY == 0)){
            return lattice[aX][cellsB - 1][1][aZ];
        }else if((aX == cellsA - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aY == cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else{
            return lattice[aX][aY - 1][1][aZ];
        }
    }else if(a.getPosS() == 1){
        if((aX == cellsA - 1) && (aY == cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else if((aX == cellsA - 1) && (aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == 0) && (aY == cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == cellsA - 1)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aY == cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else{
            return lattice[aX][aY + 1][0][aZ];
        }
    }else{
        std::cerr << "Wrong sublattice" << std::endl;
        exit(1);
        return a;
    }    
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheYDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(a.getPosS() == 0){
        if((aX == cellsA - 1) && (aY == cellsB - 1)){
            return lattice[0][aY - 1][1][aZ];
        }else if((aX == cellsA - 1) && (aY == 0)){
            return lattice[0][cellsB - 1][1][aZ];
        }else if((aX == 0) && (aY == cellsB - 1)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX + 1][cellsB - 1][1][aZ];
        }else if((aX == 0)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else if((aY == 0)){
            return lattice[aX + 1][cellsB - 1][1][aZ];
        }else if((aX == cellsA - 1)){
            return lattice[0][aY - 1][1][aZ];
        }else if((aY == cellsB - 1)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else{
            return lattice[aX + 1][aY - 1][1][aZ];
        }
    }else if(a.getPosS() == 1){
        if((aX == cellsA - 1) && (aY == cellsB - 1)){
            return lattice[aX - 1][0][0][aZ];
        }else if((aX == cellsA - 1) && (aY == 0)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aX == 0) && (aY == cellsB - 1)){
            return lattice[cellsA - 1][0][0][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[cellsA - 1][aY + 1][0][aZ];
        }else if((aX == 0)){
            return lattice[cellsA - 1][aY + 1][0][aZ];
        }else if((aY == 0)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aX == cellsA - 1)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aY == cellsB - 1)){
            return lattice[aX - 1][0][0][aZ];
        }else{
            return lattice[aX - 1][aY + 1][0][aZ];
        }
    }else{
        std::cerr << "Wrong sublattice" << std::endl;
        exit(1);
        return a;
    }
    
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheZDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(a.getPosS() == 0){
        return lattice[aX][aY][1][aZ];
    }else if(a.getPosS() == 1){
        return lattice[aX][aY][0][aZ];
    }else{
        std::cerr << "Wrong sublattice" << std::endl;
        exit(1);
        return a;
    }
    
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheUpDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(cellsC == 1){
        return a;
    }else{
        if(aZ == cellsC - 1){
            return lattice[aX][aY][a.getPosS()][0];
        }else if(aZ == 0){
            return lattice[aX][aY][a.getPosS()][aZ + 1];
        }else{
            return lattice[aX][aY][a.getPosS()][aZ + 1];
        }
    }
    return a;
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheDownDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(cellsC == 1){
        return a;
    }else{
        if(aZ == cellsC - 1){
            return lattice[aX][aY][a.getPosS()][aZ - 1];
        }else if(aZ == 0){
            return lattice[aX][aY][a.getPosS()][cellsC - 1];
        }else{
            return lattice[aX][aY][a.getPosS()][aZ - 1];
        }
    }
    return a;
    
}

void MonteCarlo::doC2Rotation001(){
    ClassicalSpin3D a;
    //cout<<"got here "<<endl;
    
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    a = lattice[i][j][k][z];
                    a.doC2Rotation001();
                    a.checkSpin();
                    //cout<<cellsA - a.getPosX()<<endl;
                    //cout<<cellsB - a.getPosY()<<endl;
                    //cout<<cellsC - a.getPosZ()<<endl;
                    //cout<<1 - a.getPosS()<<endl;
                    a.setPosX(cellsA - a.getPosX());
                    a.setPosY(cellsB - a.getPosY());
                    a.setPosZ(cellsC - a.getPosZ());
                    a.setPosS(1 - a.getPosS());                    
                }
            }
        }
    }
    //cout<<"got here psh"<<endl;
    
    std::vector< std::vector< std::vector< std::vector<ClassicalSpin3D> > > > temp;
    ClassicalSpin3D spin;
    for(int i = 0; i < cellsA; i++){
        std::vector< std::vector< std::vector<ClassicalSpin3D> > > row;
        for(int j = 0; j < cellsB; j++){
            std::vector< std::vector<ClassicalSpin3D> > col;
            for(int k = 0; k < 2; k++){
                std::vector<ClassicalSpin3D> rise;
                for(int z = 0; z < cellsC; z++){
                    
                    rise.push_back(spin);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        temp.push_back(row);
    }
    //cout<<"got here Whew"<<endl;
    
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    //cout<<i<<j<<z<<k<<endl;
                    //cout<<lattice[i][j][k][z].getPosX()<<endl;
                    temp[i][j][k][z].setPosX(lattice[i][j][k][z].getPosX()); 
                    temp[i][j][k][z].setPosY(lattice[i][j][k][z].getPosY());                   
                    temp[i][j][k][z].setPosZ(lattice[i][j][k][z].getPosZ());
                    temp[i][j][k][z].setPosS(lattice[i][j][k][z].getPosS());                   
                    temp[i][j][k][z].setX(lattice[i][j][k][z].getX());                   
                    temp[i][j][k][z].setY(lattice[i][j][k][z].getY());                   
                    temp[i][j][k][z].setZ(lattice[i][j][k][z].getZ());                     
                }
            }
        }
    }
    //cout<<"got here Whew!"<<endl;
    
    bool found = false;
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    //FindSpin
                    for(int i2 = 0; i2 < cellsA; i2++){
                        for(int j2 = 0; j2 < cellsB; j2++){
                            for(int z2 = 0; z2 < cellsC; z2++){
                                for(int k2 = 0; k2 < 2; k2++){
                                    spin = temp[i2][j2][k2][z2];
                                    //cout<<"spin"<<endl;
                                    //cout<<spin.getPosX()<<endl;
                                    //cout<<spin.getPosY()<<endl;
                                    //cout<<spin.getPosZ()<<endl;
                                    //cout<<spin.getPosS()<<endl;
                                    if(i == spin.getPosX() && j == spin.getPosY() &&
                                       z == spin.getPosZ() && k == spin.getPosS()){
                                        //cout<<i<<j<<z<<k<<endl;
                                        lattice[i][j][k][z].setPosX(temp[i][j][k][z].getPosX()); 
                                        lattice[i][j][k][z].setPosY(temp[i][j][k][z].getPosY());                   
                                        lattice[i][j][k][z].setPosZ(temp[i][j][k][z].getPosZ()); 
                                        lattice[i][j][k][z].setPosS(temp[i][j][k][z].getPosS());                   
                                        lattice[i][j][k][z].setX(temp[i][j][k][z].getX());                   
                                        lattice[i][j][k][z].setY(temp[i][j][k][z].getY());                   
                                        lattice[i][j][k][z].setZ(temp[i][j][k][z].getZ());                                          
                                        found = true;
                                    }
                                }
                            }
                        }
                    }
                    if(!found){
                        cerr << "Failed to Find Spin" << endl;
                        exit(3161990);
                    }
                    found = false;
                    //
                }
            }
        }
    }
    
}

void MonteCarlo::rotateAllSpins(double phi, double theta){
    for(int i = 0; i < cellsA; i++){
        for(int j = 0; j < cellsB; j++){
            for(int z = 0; z < cellsC; z++){
                for(int k = 0; k < 2; k++){
                    lattice[i][j][k][z].specifyRotation(phi, theta);
                }
            }
        }
    }
}


