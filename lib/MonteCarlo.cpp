
#include "MonteCarlo.h"
#include <cstddef>
#include <cmath>
#include <ctime>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>
#include <limits>
using namespace std;

string spinComponent[SPINDIMEN] = {
    "X direction",
    "Y direction",
    "Z direction",
    //"XY direction",
    //"YZ direction",
    //"ZX direction",
    //"PsuedoX",
    //"PseudoY",
    //"PseudoZ"
};
string spinComponentSmall[SPINDIMEN] = {
    "X",
    "Y",
    "Z",
    //"XY",
    //"YZ",
    //"ZX",
    //"PX",
    //"PY",
    //"PZ"
};
string powerOP[POWERSOP] = {
    " to the 1st power",
    " to the 2nd power",
    " to the 3rd power",
    " to the 4th power"
};
string typeOP[TYPESOP] = {
    "Order Parameter",
    "Cubic Order Parameter, b1",
    "Cubic Order Parameter, b2",
    "Magnitude of Cubic Order Parameter, |b|",
    "Order Parameter, m1",
    "Order Parameter, m2",
    "Magnitude of Order Parameter, |m|",
    "X Component of the Spin",
    "Y Component of the Spin",
    "Z Component of the Spin",
    //"XY Component of the Spin",
    //"YZ Component of the Spin",
    //"ZX Component of the Spin",
    //"X Component of the Pseudospin",
    //"Y Component of the Pseudospin",
    //"Z Component of the Pseudospin",
    //"Order Parameter of Pseudospin"
};
//First, an array is created for each order parameter
//The array is the number of elements as the spin dimension
//the array is added to in order to create the order parameter * N.
//At the end, we have a sum over the lattice - each spin has been summed over.
//The M order Parameter will keep track of strickly the spin component summed.
//From here, The typeOP are generated by manipulating the sum average spin -
//the snapshot of the entire lattice which computes these.
string orderParameter[NUMVECTORS] = {
    "Magnetization",
    "Neel",
    "Stripy-1",
    "Stripy-2",
    "Stripy-3",
    "Stripy",
    "Neel-3D",
    "ZigZag-1",
    "ZigZag-2",
    "ZigZag-3",
    "ZigZag"
};
string orderParameterSmall[NUMVECTORS] = {
    "M",
    "N",
    "S1",
    "S2",
    "S3",
    "S",
    "N3D",
    "ZZ1",
    "ZZ2",
    "ZZ3",
    "ZZ"
};
string sumOPNames       [NUMVECTORS][TYPESOP][POWERSOP] = {""};
string charOPNames      [NUMVECTORS][TYPESOP] = {""};

void MonteCarlo::setParamNames(){
    cout<<"Set Names"<<endl;
    
    stringstream name;
    for(int i = 0; i < NUMVECTORS; i ++){
        for(int j = 0; j < TYPESOP; j++){
            name.str("");
            name << orderParameter[i] << "'s "<< typeOP[j];
            charOPNames[i][j] = name.str();
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i ++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                name.str("");
                name << orderParameter[i] << "'s "<< typeOP[j] << powerOP[k];
                sumOPNames[i][j][k] = name.str();
            }
        }
    }
    
}

void MonteCarlo::setLCToZero(){
    cout<<"Set Lat Chars to Zero"<<endl;
    
    //Setting Lat Chars to zero.
    for(int i = 0; i < POWERSOP; i++){
        LC.sumE[i] = 0;
        LC.sumTB[i] = 0;
        LC.sumAB[i] = 0;
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                LC.sumOP[i][j][k] = 0;
            }
        }
    }
    
    //Setting correlation function to zero
    for(int count = 0; count < NUMCORRSPINSBIG; count++){
        LC.sumECorrFunc[count] = 0;
        LC.sumTBCorrFunc[count] = 0;
        LC.sumABCorrFunc[count] = 0;
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                LC.sumOPCorrFunc[i][j][count] = 0;
            }
        }
    }
    
}

void MonteCarlo::setOPToZero(){
    cout<<"Set OP to Zero"<<endl;
    
    //Setting OP to zero.
    OP.E = 0;
    OP.TB = 0;
    OP.AB = 0;
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            OP.charOP[i][j] = 0;
        }
    }
    
    //Setting correlation function to zero
    for(int count = 0; count < NUMCORRSPINSBIG; count++){
        OP.ECorrFunc[count] = 0;
        OP.TBCorrFunc[count] = 0;
        OP.ABCorrFunc[count] = 0;
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                OP.corrFunc[i][j][count] = 0;
            }
        }
    }
}

void MonteCarlo::setMCPToZero(){
    cout<<"Set MCP to Zero"<<endl;
    MCP.isDomainWalls = false;
    MCP.directionOfDomain = 0;
    MCP.isRotHam    = false;
    MCP.isAlphaHam  = false;
    MCP.alpha       = 0;
    MCP.isJ23Term   = false;
    MCP.j2          = 0;
    MCP.j3          = 0;
    MCP.k2          = 0;
    MCP.isCubeHam   = false;
    MCP.cubicD      = 0;
    MCP.isBField    = false;
    MCP.bField_x    = 0;
    MCP.bField_y    = 0;
    MCP.bField_z    = 0;
    MCP.bFieldMag   = 0;
    MCP.isPhiHam    = true;
    MCP.phi         = 0;
    MCP.cellsA      = 2;
    MCP.cellsB      = 2;
    MCP.cellsC      = 1;
    MCP.KbT         = 0;
    
    MCP.estimatedTc = 0.2;
    MCP.numSweepsToPerformTotal = 1;
    MCP.bField_xNorm = 0;
    MCP.bField_yNorm = 0;
    MCP.bField_zNorm = 0;
}

void MonteCarlo::setMDToZero(){
    cout<<"Set MD to Zero"<<endl;
    
    MD.flipAttempts    = 0;
    MD.successfulFlips = 0;
    MD.range           = PI-0.1;
    MD.rangeOld        = 0.1;
    MD.numConfigsDone  = 0;
    MD.isThermal        = false;
    MD.numSweepsPerformedToCheckIfThermalized = 0;
    MD.numSweepsPerformed           = 0;
    MD.numSweepsUsedToThermalize    = 0;
    MD.timeOfInitialization         = 0;
    
}

void MonteCarlo::setRecipToZero(){
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < MCP.cellsC; z++){
                    sumOverRecipLattice[i][j][k][z].ReXComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ReYComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ReZComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImXComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImYComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImZComponent = 0;
                    sumOverRecipLattice[i][j][k][z].magnitude = 0;
                    
                    recipLattice[i][j][k][z].ReXComponent = 0;
                    recipLattice[i][j][k][z].ReYComponent = 0;
                    recipLattice[i][j][k][z].ReZComponent = 0;
                    recipLattice[i][j][k][z].ImXComponent = 0;
                    recipLattice[i][j][k][z].ImYComponent = 0;
                    recipLattice[i][j][k][z].ImZComponent = 0;
                    recipLattice[i][j][k][z].magnitude = 0;
                }
            }
        }
    }
    
    
}

void MonteCarlo::initializeLattice(){
    //Constructs and initializes the lattice to random spins
    ClassicalSpin3D spin;
    for(int i = 0; i < MCP.cellsA; i++){
        std::vector< std::vector< std::vector<ClassicalSpin3D> > > row;
        for(int j = 0; j < MCP.cellsB; j++){
            std::vector< std::vector<ClassicalSpin3D> > col;
            for(int k = 0; k < 2; k++){
                std::vector<ClassicalSpin3D> rise;
                for(int z = 0; z < MCP.cellsC; z++){
                    rise.push_back(spin);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        lattice.push_back(row);
    }
    
    FourierTransformOfSpin spinFT;
    for(int i = 0; i < MCP.cellsA; i++){
        std::vector< std::vector< std::vector<FourierTransformOfSpin> > > row;
        for(int j = 0; j < MCP.cellsB; j++){
            std::vector< std::vector<FourierTransformOfSpin> > col;
            for(int k = 0; k < 2; k++){
                std::vector<FourierTransformOfSpin> rise;
                for(int z = 0; z < MCP.cellsC; z++){
                    rise.push_back(spinFT);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        recipLattice.push_back(row);
    }
    
    for(int i = 0; i < MCP.cellsA; i++){
        std::vector< std::vector< std::vector<FourierTransformOfSpin> > > row;
        for(int j = 0; j < MCP.cellsB; j++){
            std::vector< std::vector<FourierTransformOfSpin> > col;
            for(int k = 0; k < 2; k++){
                std::vector<FourierTransformOfSpin> rise;
                for(int z = 0; z < MCP.cellsC; z++){
                    rise.push_back(spinFT);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        sumOverRecipLattice.push_back(row);
    }
    
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < MCP.cellsC; z++){
                    lattice[i][j][k][z].setX(0);
                    lattice[i][j][k][z].setY(0);
                    lattice[i][j][k][z].setZ(1);
                    //lattice[i][j][k][z].setRandomOrientation();
                    lattice[i][j][k][z].setPosX(i);
                    lattice[i][j][k][z].setPosY(j);
                    lattice[i][j][k][z].setPosS(k);
                    lattice[i][j][k][z].setPosZ(z);
                    
                    recipLattice[i][j][k][z].ReXComponent = 0;
                    recipLattice[i][j][k][z].ReYComponent = 0;
                    recipLattice[i][j][k][z].ReZComponent = 0;
                    recipLattice[i][j][k][z].ImXComponent = 0;
                    recipLattice[i][j][k][z].ImYComponent = 0;
                    recipLattice[i][j][k][z].ImZComponent = 0;
                    recipLattice[i][j][k][z].magnitude = 0;
                    sumOverRecipLattice[i][j][k][z].ReXComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ReYComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ReZComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImXComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImYComponent = 0;
                    sumOverRecipLattice[i][j][k][z].ImZComponent = 0;
                    sumOverRecipLattice[i][j][k][z].magnitude = 0;
                }
            }
        }
    }
    
    if(MCP.isDomainWalls){
        SetDomainWall();
    }
}

double MonteCarlo::getPolarAngleTB(const double spinX, const double spinY, const double spinZ){
    //OP: TB, Polar Angle to B Field
    double Bfield[3] = {0};
    Bfield[0] = MCP.bField_x;
    Bfield[1] = MCP.bField_y;
    Bfield[2] = MCP.bField_z;
    double spin[3] = {0};
    spin[0] = spinX;
    spin[1] = spinY;
    spin[2] = spinZ;
    
    //Norming is important because in general the vectors (of spin at least) are
    //not normalized
    double normB = sqrt(dotProd(Bfield,Bfield));
    double normS = sqrt(dotProd(spin,spin));
    double cosTB = dotProd(spin, Bfield)/(normB * normS);
    
    if((cosTB > 1.0000001)||(cosTB < -1.00000001)){
        cout<<"bad TB "<<cosTB<<endl;
        cerr<<"bad TB "<<cosTB<<endl;
        exit(1);
    }
    if((cosTB > 1.0)){
        cosTB = 1;
    }
    if((cosTB < -1.0)){
        cosTB = -1;
    }
    
    return acos(cosTB);
    //End OP TB
    
}

double MonteCarlo::getAziAngleAB(const double spinX, const double spinY, const double spinZ){
    //OP: AB, Azimuthal Angle to the B Field
    
    /*
     Unlike finding the polar angle to the B field, the azimuthal angle is
     slightly more subtle. To completely specify the orientation of the
     azimuthal angle, we will construct a right handed coordinate system which
     will fully define the azimuthal angle.
     If the direction of the B field is analogous to a "z" direction,
     then define n to be analogous to the "x" direction via: n = B x z
     where B is the direction of the external field and z is the "c"crystal axis.
     if B is along z, then let n = x. where x is the "a" crystal axis.
     Finally, we define m = B x n - analogous to the "b" crystal axis.
     */
    
    //Norming is important because in general the vectors (of spin at least) are
    //not normalized
    double Bfield[3] = {0};
    Bfield[0] = MCP.bField_x;
    Bfield[1] = MCP.bField_y;
    Bfield[2] = MCP.bField_z;
    double normB = sqrt(dotProd(Bfield,Bfield));
    
    Bfield[0] = Bfield[0] / normB;
    Bfield[1] = Bfield[1] / normB;
    Bfield[2] = Bfield[2] / normB;
    
    double spin[3] = {0};
    spin[0] = spinX;
    spin[1] = spinY;
    spin[2] = spinZ;
    double normS = sqrt(dotProd(spin,spin));
    
    spin[0] = spin[0] / normS;
    spin[1] = spin[1] / normS;
    spin[2] = spin[2] / normS;
    
    //Bfield is analogous to the z direction
    //nhat = B cross zhat - This is analogous to the x direction
    double nhat[3] = {0};
    nhat[0] = MCP.bField_y;//y->x in cross products
    nhat[1] = (-1)*MCP.bField_x;
    nhat[2] = 0;
    
    if(fabs(MCP.bField_z - 1) < 1e-5){
        nhat[0] = 1;
        nhat[1] = 0;
        nhat[2] = 0;
    }
    if(fabs(MCP.bField_z - (-1)) < 1e-5){
        nhat[0] = -1;
        nhat[1] = 0;
        nhat[2] = 0;
    }
    
    double normN = sqrt(dotProd(nhat, nhat));
    nhat[0] = nhat[0] / normN;
    nhat[1] = nhat[1] / normN;
    nhat[2] = nhat[2] / normN;
    
    //Third axis definition, the resultant from B x n
    double vert[3] = {0};
    vert[0] =           Bfield[1] * nhat[2] - Bfield[2] * nhat[1];
    vert[1] = (-1) *   (Bfield[0] * nhat[2] - Bfield[2] * nhat[0]);
    vert[2] =           Bfield[0] * nhat[1] - Bfield[1] * nhat[0];
    double normV = sqrt(dotProd(vert, vert));
    vert[0] = vert[0] / normV;
    vert[1] = vert[1] / normV;
    vert[2] = vert[2] / normV;
    
    //projecting the spin into the plane perpendicular to the B field.
    double spinProjIntoPerpPlane[3] = {0};
    spinProjIntoPerpPlane[0] = spinX - (dotProd(spin, Bfield) * Bfield[0]/dotProd(Bfield, Bfield));
    spinProjIntoPerpPlane[1] = spinY - (dotProd(spin, Bfield) * Bfield[1]/dotProd(Bfield, Bfield));
    spinProjIntoPerpPlane[2] = spinZ - (dotProd(spin, Bfield) * Bfield[2]/dotProd(Bfield, Bfield));
    double normSP = sqrt(dotProd(spinProjIntoPerpPlane, spinProjIntoPerpPlane));
    spinProjIntoPerpPlane[0] = spinProjIntoPerpPlane[0] / normSP;
    spinProjIntoPerpPlane[1] = spinProjIntoPerpPlane[1] / normSP;
    spinProjIntoPerpPlane[2] = spinProjIntoPerpPlane[2] / normSP;
    
    //At this point, the dot product of spinProjIntoPerpPlane with nhat will
    //yield cos(AB). But this is sign insensitive - choose nhat to be the "x"
    //and ccw, [0,2pi) is the AB angle. This means that when the dot product of
    //vert and spinProjIntoPerpPlane are greater than 0, then 0 < AB < pi and
    //vert and spinProjIntoPerpPlane are less than 0, then pi < AB < 2pi.
    
    if(dotProd(spinProjIntoPerpPlane, vert) == 0){
        if(dotProd(spinProjIntoPerpPlane, nhat) > 0){
            return 0;
        }else{
            return PI;
        }
    }
    
    double cosAB = dotProd(spinProjIntoPerpPlane, nhat);
    if((cosAB > 1.0000001)||(cosAB < -1.00000001)){
        cout<<"bad AB "<<cosAB<<endl;
        cerr<<"bad AB "<<cosAB<<endl;
        exit(1);
    }
    if((cosAB > 1.0)){
        cosAB = 1;
    }
    if((cosAB < -1.0)){
        cosAB = -1;
    }
    double OPAB = acos(cosAB);
    
    if(dotProd(spinProjIntoPerpPlane, vert) < 0){
        OPAB = 2 * PI - OPAB;
    }
    
    return OPAB;
    
    //End OP: AB
}





void MonteCarlo::setSpinComponent(string component){
    int xPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int yPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int zPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int sPos = atoi(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double xComp = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double yComp = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double zComp = atof(component.substr(0,component.find(" ")).c_str());
    lattice[xPos][yPos][sPos][zPos].setX(xComp);
    lattice[xPos][yPos][sPos][zPos].setY(yComp);
    lattice[xPos][yPos][sPos][zPos].setZ(zComp);
    //cout<< "Component: " << xPos << " " << yPos << " " << sPos << " " <<
    //zPos << " " << xComp<< " " << yComp << " " << zComp<<endl;
}

void MonteCarlo::setRecipLatComponent(string component){
    int xPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int yPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int zPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int sPos = atoi(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_x = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_y = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_z = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_x = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_y = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_z = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double magnitude = atof(component.substr(0,component.find(" ")).c_str());
    recipLattice[xPos][yPos][sPos][zPos].ReXComponent = ReSq_x;
    recipLattice[xPos][yPos][sPos][zPos].ReYComponent = ReSq_y;
    recipLattice[xPos][yPos][sPos][zPos].ReZComponent = ReSq_z;
    recipLattice[xPos][yPos][sPos][zPos].ImXComponent = ImSq_x;
    recipLattice[xPos][yPos][sPos][zPos].ImYComponent = ImSq_y;
    recipLattice[xPos][yPos][sPos][zPos].ImZComponent = ImSq_z;
    recipLattice[xPos][yPos][sPos][zPos].magnitude = magnitude;
    //cout<< "Reciprocal Lattice, S(q): " << xPos << " " << yPos << " " << sPos << " " <<
    //zPos << " " << ReSq_x << " " << ReSq_y << " " << ReSq_z << " " <<
    //ImSq_x << " " << ImSq_y << " " << ImSq_z << " " << magnitude << endl;
}

void MonteCarlo::setSumOverRecipLatComponent(string component){
    int xPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int yPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int zPos = atoi(component.substr(0,component.find(",")).c_str());
    component = component.substr(1 + component.find(","));
    int sPos = atoi(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_x = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_y = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ReSq_z = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_x = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_y = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double ImSq_z = atof(component.substr(0,component.find(" ")).c_str());
    component = component.substr(1 + component.find(" "));
    double magnitude = atof(component.substr(0,component.find(" ")).c_str());
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ReXComponent = ReSq_x;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ReYComponent = ReSq_y;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ReZComponent = ReSq_z;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ImXComponent = ImSq_x;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ImYComponent = ImSq_y;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].ImZComponent = ImSq_z;
    sumOverRecipLattice[xPos][yPos][sPos][zPos].magnitude = magnitude;
    //cout<< "Reciprocal Lattice, Sum Over S(q): " << xPos << " " << yPos << " " << sPos << " " <<
    //zPos << " " << ReSq_x << " " << ReSq_y << " " << ReSq_z << " " <<
    //ImSq_x << " " << ImSq_y << " " << ImSq_z << " " << magnitude << endl;
}

void MonteCarlo::init(){
    
    //initialize private variables
    
    setLCToZero();
    
    setOPToZero();
    
    setMCPToZero();
    
    setMDToZero();
    
    setParamNames();
    
    outputMag           = "";
    
    
    cout<<"Finished with init()"<<endl;
    
}

MonteCarlo::MonteCarlo(){
    init();
    
    initializeLattice();
    
    
    cout<<"Finished with default MC constructor"<<endl;
    MD.timeOfInitialization = clock();
    
}

MonteCarlo::MonteCarlo(bool     isDomainWalls_,
                       int      directionOfDomain_,
                       bool     isRotHam_,
                       bool     isAlphaHam_,
                       double   alpha_,
                       bool     isJ23Term_,
                       double   j2_,
                       double   j3_,
                       double   k2_,
                       bool     isCubeHam_,
                       double   cubicD_,
                       bool     isBField_,
                       double   bField_x_,
                       double   bField_y_,
                       double   bField_z_,
                       double   bFieldMag_,
                       bool     isPhiHam_,
                       double   phi_,
                       int      cellsA_,
                       int      cellsB_,
                       int      cellsC_,
                       double   KbT_,
                       double   estimatedTc_,
                       int      numSweepsToPerformTotal_,
                       string   fileName_){
    
    init();
    
    //initialize private variables
    MCP.KbT         = KbT_;
    MCP.cellsA      = cellsA_;
    MCP.cellsB      = cellsB_;
    MCP.cellsC      = cellsC_;
    MCP.isCubeHam   = isCubeHam_;
    MCP.cubicD      = cubicD_;
    MCP.isRotHam    = isRotHam_;
    MCP.isAlphaHam  = isAlphaHam_;
    MCP.alpha       = alpha_;
    MCP.isPhiHam    = isPhiHam_;
    MCP.phi         = phi_;
    MCP.isJ23Term   = isJ23Term_;
    MCP.j2          = j2_;
    MCP.j3          = j3_;
    MCP.k2          = k2_;
    MCP.isBField    = isBField_;
    MCP.bField_x    = bField_x_;
    MCP.bField_y    = bField_y_;
    MCP.bField_z    = bField_z_;
    MCP.bFieldMag   = bFieldMag_;
    MCP.estimatedTc = estimatedTc_;
    MCP.numSweepsToPerformTotal = numSweepsToPerformTotal_;
    MCP.isDomainWalls           = isDomainWalls_;
    MCP.directionOfDomain       = directionOfDomain_;
    
    int bigNum  = 10 * 1000 * 1000;
    MCP.alpha       = ((int) (bigNum * MCP.alpha)) / (1.0 * bigNum);
    MCP.j2          = ((int) (bigNum * MCP.j2)) / (1.0 * bigNum);
    MCP.j3          = ((int) (bigNum * MCP.j3)) / (1.0 * bigNum);
    MCP.k2          = ((int) (bigNum * MCP.k2)) / (1.0 * bigNum);
    MCP.cubicD      = ((int) (bigNum * MCP.cubicD)) / (1.0 * bigNum);
    MCP.bFieldMag   = ((int) (bigNum * MCP.bFieldMag)) / (1.0 * bigNum);
    MCP.phi         = ((int) (bigNum * MCP.phi)) / (1.0 * bigNum);
    MCP.KbT         = ((int) (bigNum * MCP.KbT)) / (1.0 * bigNum);
    
    MD.flipAttempts    = 0;
    MD.successfulFlips = 0;
    MD.range           = PI-0.1;
    MD.rangeOld        = 0.1;
    MD.numConfigsDone  = 0;
    MD.isThermal        = false;
    MD.numSweepsPerformedToCheckIfThermalized = 0;
    MD.numSweepsPerformed           = 0;
    MD.numSweepsUsedToThermalize    = 0;
    
    outputMag           = fileName_;
    
    if(MCP.isBField){
        double size = sqrt(MCP.bField_x * MCP.bField_x +
                           MCP.bField_y * MCP.bField_y +
                           MCP.bField_z * MCP.bField_z);
        
        MCP.bField_xNorm = MCP.bFieldMag * MCP.bField_x / size;
        MCP.bField_yNorm = MCP.bFieldMag * MCP.bField_y / size;
        MCP.bField_zNorm = MCP.bFieldMag * MCP.bField_z / size;
    }
    
    initializeLattice();
    
    MD.timeOfInitialization = clock();
    
    cout<<"Finished with (new) MC constructor"<<endl;
}

//This function initializes the lattice through copying data from a previous run.
MonteCarlo::MonteCarlo(bool reThermalize, string filename){
    init();
    
    //Reading in the rest of the lattice information from the saved file
    outputMag = filename;
    
    string line = "";
    ifstream file;
    file.clear();
    file.open(outputMag.c_str());
    if (!file.is_open() || !file.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    line = "";
    string search = "";
    while(file.good()){
        getline (file,line);
        if(line.find("End information for this configuration") !=
           string::npos){
            break;
        }
        
        //Retrieving the lattice properties from the text fil
        
        MCP.KbT = findParameterDbl(MCP.KbT, line, "KbT: ");
        MCP.cellsA = findParameterInt(MCP.cellsA, line, "Cells-A: ");
        MCP.cellsB = findParameterInt(MCP.cellsB, line, "Cells-B: ");
        MCP.cellsC = findParameterInt(MCP.cellsC, line, "Cells-C: ");
        MCP.isCubeHam = findParameterInt(MCP.isCubeHam, line, "Is Cubic Hamiltonian?: ");
        MCP.cubicD = findParameterDbl(MCP.cubicD, line, "cubicD: ");
        MCP.isRotHam = findParameterInt(MCP.isRotHam, line, "Is Rotated Hamiltonian?: ");
        MCP.isAlphaHam = findParameterInt(MCP.isAlphaHam, line, "Is Alpha Hamiltonian?: ");
        MCP.alpha = findParameterDbl(MCP.alpha, line, "alpha: ");
        MCP.isPhiHam = findParameterInt(MCP.isPhiHam, line, "Is Phi (Extended) Hamiltonian?: ");
        MCP.phi = findParameterDbl(MCP.phi, line, "phi: ");
        MCP.isJ23Term = findParameterInt(MCP.isJ23Term, line, "Is J23 Hamiltonian?: ");
        MCP.j2 = findParameterDbl(MCP.j2, line, "j2: ");
        MCP.j3 = findParameterDbl(MCP.j3, line, "j3: ");
        MCP.k2 = findParameterDbl(MCP.k2, line, "k2: ");
        MCP.isBField = findParameterInt(MCP.isBField, line, "Is External Magnetic Field?: ");
        MCP.bField_x = findParameterDbl(MCP.bField_x, line, "bField_x: ");
        MCP.bField_y = findParameterDbl(MCP.bField_y, line, "bField_y: ");
        MCP.bField_z = findParameterDbl(MCP.bField_z, line, "bField_z: ");
        MCP.bFieldMag = findParameterDbl(MCP.bFieldMag, line, "bFieldMag: ");
        MCP.estimatedTc = findParameterDbl(MCP.estimatedTc, line, "estimatedTc: ");
        MCP.numSweepsToPerformTotal = findParameterInt(MCP.numSweepsToPerformTotal, line, "numSweepsToPerformTotal: ");
        MCP.isDomainWalls = findParameterInt(MCP.isDomainWalls, line, "isDomainWalls: ");
        MCP.directionOfDomain = findParameterInt(MCP.directionOfDomain, line, "directionOfDomain: ");
        
        MD.range = findParameterDbl(MD.range, line, "Flip Range: ");
        MD.numConfigsDone = findParameterInt(MD.numConfigsDone, line, "numConfigsDone: ");
        MD.isThermal = findParameterInt(MD.isThermal, line, "isThermal: ");
        MD.numSweepsPerformedToCheckIfThermalized =
        findParameterInt(MD.numSweepsPerformedToCheckIfThermalized,
                         line,
                         "numSweepsPerformedToCheckIfThermalized: ");
        MD.numSweepsPerformed = findParameterInt(MD.numSweepsPerformed, line, "numSweepsPerformed: ");
        MD.numSweepsUsedToThermalize = findParameterInt(MD.numSweepsUsedToThermalize, line, "numSweepsUsedToThermalize: ");
        
        if ((!reThermalize)&&
            (MD.numSweepsPerformed >= MCP.numSweepsToPerformTotal)) {
            cout<<"!!!Finished Simulation!!!"<<endl;
            exit(0);
        }
        
        //Reading in the Lattice Characteristics
        if (line.find("Sum over Configurations, ") != string::npos) {
            stringstream ss;
            for(int i = 0; i < NUMVECTORS; i++){
                for(int j = 0; j < TYPESOP; j++){
                    for(int k = 0; k < POWERSOP; k++){
                        ss.str("");
                        ss << "Sum over Configurations, " << sumOPNames[i][j][k] << ": ";
                        LC.sumOP[i][j][k] = findParameterDbl(LC.sumOP[i][j][k], line,
                                                             ss.str());
                    }
                }
            }
            //E
            ss.str("");
            ss << "Sum over Configurations, Energy to the 1st power: ";
            LC.sumE[0] = findParameterDbl(LC.sumE[0], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Energy to the 2nd power: ";
            LC.sumE[1] = findParameterDbl(LC.sumE[1], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Energy to the 3rd power: ";
            LC.sumE[2] = findParameterDbl(LC.sumE[2], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Energy to the 4th power: ";
            LC.sumE[3] = findParameterDbl(LC.sumE[3], line, ss.str());
            //TB
            ss.str("");
            ss << "Sum over Configurations, Polar Angle to B Field to the 1st power: ";
            LC.sumTB[0] = findParameterDbl(LC.sumTB[0], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Polar Angle to B Field to the 2nd power: ";
            LC.sumTB[1] = findParameterDbl(LC.sumTB[1], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Polar Angle to B Field to the 3rd power: ";
            LC.sumTB[2] = findParameterDbl(LC.sumTB[2], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Polar Angle to B Field to the 4th power: ";
            LC.sumTB[3] = findParameterDbl(LC.sumTB[3], line, ss.str());
            //AB
            ss.str("");
            ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 1st power: ";
            LC.sumAB[0] = findParameterDbl(LC.sumAB[0], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 2nd power: ";
            LC.sumAB[1] = findParameterDbl(LC.sumAB[1], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 3rd power: ";
            LC.sumAB[2] = findParameterDbl(LC.sumAB[2], line, ss.str());
            ss.str("");
            ss << "Sum over Configurations, Azimuthal Angle to the B Field to the 4th power: ";
            LC.sumAB[3] = findParameterDbl(LC.sumAB[3], line, ss.str());
        }
        //End explicit labeling for scalar quantities
        
        //Correlation function
        if (line.find("Sum over Configurations, Correlation Function - ") != string::npos) {
            stringstream ss;
            for(int count = 0; count < MCP.cellsA*2; count++){
                ss.str("");
                ss << "Sum over Configurations, Correlation Function - between " << count << " Nearest Neighbors - ";
                if (line.find(ss.str()) != string::npos) {
                    for(int i = 0; i < NUMVECTORS; i++){
                        for(int j = 0; j < TYPESOP; j++){
                            ss.str("");
                            ss << "Sum over Configurations, Correlation Function - ";
                            ss << "between " << count << " Nearest Neighbors - ";
                            ss << charOPNames[i][j] << ": ";
                            LC.sumOPCorrFunc[i][j][count] = findParameterDbl(LC.sumOPCorrFunc[i][j][count],
                                                                             line, ss.str());
                        }
                    }
                }
            }
            for(int count = 0; count < MCP.cellsA*2; count++){
                //E
                ss.str("");
                ss << "Sum over Configurations, Correlation Function - ";
                ss << "between " << count << " Nearest Neighbors - ";
                ss << "Energy to the 1st power: ";
                LC.sumECorrFunc[count] = findParameterDbl(LC.sumECorrFunc[count], line, ss.str());
                //TB
                ss.str("");
                ss << "Sum over Configurations, Correlation Function - ";
                ss << "between " << count << " Nearest Neighbors - ";
                ss << "Polar Angle to B Field to the 1st power: ";
                LC.sumTBCorrFunc[count] = findParameterDbl(LC.sumTBCorrFunc[count], line, ss.str());
                //AB
                ss.str("");
                ss << "Sum over Configurations, Correlation Function - ";
                ss << "between " << count << " Nearest Neighbors - ";
                ss << "Azimuthal Angle to the B Field to the 1st power: ";
                LC.sumABCorrFunc[count] = findParameterDbl(LC.sumABCorrFunc[count], line, ss.str());
            }
        }
    }
    
    
    cout<<"Finished with reading in all lattice chars"<<endl;
    file.close();
    
    initializeLattice();
    
    //Copying Spin Components
    line = "";
    file.clear();
    file.open(outputMag.c_str());
    if (!file.is_open() || !file.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    line = "";
    search = "";
    while(file.good()){
        getline (file,line);
        //cout<<line<<endl;
        if(line.find("End information for this configuration") !=
           string::npos){
            break;
        }
        search = "Components of Spin ";
        if(line.find(search.c_str()) != string::npos){
            setSpinComponent(line.substr(search.size()).c_str());
        }
        search = "Reciprocal Lattice, S(q): ";
        if(line.find(search.c_str()) != string::npos){
            setRecipLatComponent(line.substr(search.size()).c_str());
        }
        search = "Reciprocal Lattice, Sum Over S(q): ";
        if(line.find(search.c_str()) != string::npos){
            setSumOverRecipLatComponent(line.substr(search.size()).c_str());
        }
    }
    file.close();
    
    if(MCP.isBField){
        double size = sqrt(MCP.bField_x * MCP.bField_x +
                           MCP.bField_y * MCP.bField_y +
                           MCP.bField_z * MCP.bField_z);
        
        MCP.bField_xNorm = MCP.bFieldMag * MCP.bField_x / size;
        MCP.bField_yNorm = MCP.bFieldMag * MCP.bField_y / size;
        MCP.bField_zNorm = MCP.bFieldMag * MCP.bField_z / size;
    }
    
    if(MCP.isDomainWalls){
        SetDomainWall();
    }
    
    cout<<"Finished with reading in all components"<<endl;
    
    //cout<< toString()<<endl;
    
    cout<<"Finished with MC constructor"<<endl;
    
    if(reThermalize){
        cout<< "ReThermalizing. Setting All Char to Zero and setting ";
        cout<< "Thermalization data to Zero." << endl;
        setLCToZero();
        setOPToZero();
        setMDToZero();
        setRecipToZero();
        
        for(int i = 0; i < MCP.cellsA; i++){
            for(int j = 0; j < MCP.cellsB; j++){
                for(int k = 0; k < 2; k++){
                    for(int z = 0; z < MCP.cellsC; z++){
                        lattice[i][j][k][z].setRandomOrientation();
                        lattice[i][j][k][z].setPosX(i);
                        lattice[i][j][k][z].setPosY(j);
                        lattice[i][j][k][z].setPosS(k);
                        lattice[i][j][k][z].setPosZ(z);
                        
                        recipLattice[i][j][k][z].ReXComponent = 0;
                        recipLattice[i][j][k][z].ReYComponent = 0;
                        recipLattice[i][j][k][z].ReZComponent = 0;
                        recipLattice[i][j][k][z].ImXComponent = 0;
                        recipLattice[i][j][k][z].ImYComponent = 0;
                        recipLattice[i][j][k][z].ImZComponent = 0;
                        recipLattice[i][j][k][z].magnitude = 0;
                        sumOverRecipLattice[i][j][k][z].ReXComponent = 0;
                        sumOverRecipLattice[i][j][k][z].ReYComponent = 0;
                        sumOverRecipLattice[i][j][k][z].ReZComponent = 0;
                        sumOverRecipLattice[i][j][k][z].ImXComponent = 0;
                        sumOverRecipLattice[i][j][k][z].ImYComponent = 0;
                        sumOverRecipLattice[i][j][k][z].ImZComponent = 0;
                        sumOverRecipLattice[i][j][k][z].magnitude = 0;
                    }
                }
            }
        }
        
        MD.timeOfInitialization = clock();
        
    }
    
    if(MCP.isDomainWalls){
        SetDomainWall();
    }
    
}

string MonteCarlo::toString(){
    
    //To print out the Lattice characteristics
    stringstream stream;
    stream.str("");
    stream << "KbT: " << MCP.KbT << endl;
    stream << "Cells-A: " << MCP.cellsA << endl;
    stream << "Cells-B: " << MCP.cellsB << endl;
    stream << "Cells-C: " << MCP.cellsC << endl;
    stream << "Is Cubic Hamiltonian?: " << MCP.isCubeHam << endl;
    stream << "cubicD: " << MCP.cubicD << endl;
    stream << "Is Rotated Hamiltonian?: " << MCP.isRotHam << endl;
    stream << "Is Alpha Hamiltonian?: " << MCP.isAlphaHam << endl;
    stream << "alpha: " << MCP.alpha << endl;
    stream << "Is Phi (Extended) Hamiltonian?: " << MCP.isPhiHam << endl;
    stream << "phi: " << MCP.phi << endl;
    stream << "Is J23 Hamiltonian?: " << MCP.isJ23Term << endl;
    stream << "j2: " << MCP.j2 << endl;
    stream << "j3: " << MCP.j3 << endl;
    stream << "k2: " << MCP.k2 << endl;
    stream << "Is External Magnetic Field?: " << MCP.isBField << endl;
    stream << "bField_x: "<< MCP.bField_x << endl;
    stream << "bField_y: "<< MCP.bField_y << endl;
    stream << "bField_z: "<< MCP.bField_z << endl;
    stream << "bFieldMag: "<< MCP.bFieldMag << endl;
    stream << "estimatedTc: " << MCP.estimatedTc << endl;
    stream << "numSweepsToPerformTotal: " << MCP.numSweepsToPerformTotal << endl;
    stream << "isDomainWalls: " << MCP.isDomainWalls << endl;
    stream << "directionOfDomain: " << MCP.directionOfDomain << endl;
    
    stream << "Flip Range: " << MD.range << endl;
    stream << "numConfigsDone: " << MD.numConfigsDone << endl;
    stream << "isThermal: " << MD.isThermal << endl;
    stream << "numSweepsPerformed: " << MD.numSweepsPerformed << endl;
    stream << "numSweepsUsedToThermalize: " << MD.numSweepsUsedToThermalize << endl;
    stream << "numSweepsPerformedToCheckIfThermalized: " << MD.numSweepsPerformedToCheckIfThermalized << endl;
    
    stream << "Flip Success percentage: " << MD.successfulFlips/MD.flipAttempts<<endl;
    
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Current Snapshot, " << charOPNames[i][j] << ": ";
            stream << std::scientific << std::setprecision(PR) << OP.charOP[i][j] << endl;
        }
    }
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                stream << "Sum over Configurations, " << sumOPNames[i][j][k] << ": ";
                stream << std::scientific << std::setprecision(PR) << LC.sumOP[i][j][k] << endl;
            }
        }
    }
    
    
    //E
    stream << "Current Snapshot, Energy: ";
    stream << std::scientific << std::setprecision(PR) << OP.E << endl;
    stream << "Sum over Configurations, Energy to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[0] << endl;
    stream << "Sum over Configurations, Energy to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[1] << endl;
    stream << "Sum over Configurations, Energy to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[2] << endl;
    stream << "Sum over Configurations, Energy to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumE[3] << endl;
    //TB
    stream << "Current Snapshot, Polar Angle to B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.TB << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[0] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[1] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[2] << endl;
    stream << "Sum over Configurations, Polar Angle to B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumTB[3] << endl;
    //AB
    stream << "Current Snapshot, Azimuthal Angle to the B Field: ";
    stream << std::scientific << std::setprecision(PR) << OP.AB << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[0] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[1] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[2] << endl;
    stream << "Sum over Configurations, Azimuthal Angle to the B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << LC.sumAB[3] << endl;
    
    //Snapshot of M
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    stream << "Components of Spin " << i << "," << j << "," <<
                    z << "," << k << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getX() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getY() << " " <<
                    std::scientific << std::setprecision(PR) <<
                    lattice[i][j][k][z].getZ() << endl;
                }
            }
        }
    }
    
    //Snapshot of Recip Lattice
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    stream << "Reciprocal Lattice, S(q): " << i << "," << j << "," <<
                    z << "," << k << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ReXComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ReYComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ReZComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ImXComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ImYComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].ImZComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    recipLattice[i][j][k][z].magnitude << endl;
                }
            }
        }
    }
    
    //Sum over recip lattice
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    
                    stream << "Reciprocal Lattice, Sum Over S(q): " << i << "," << j << "," <<
                    z << "," << k << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ReXComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ReYComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ReZComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ImXComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ImYComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].ImZComponent << " " <<
                    std::scientific << std::setprecision(PR) <<
                    sumOverRecipLattice[i][j][k][z].magnitude << " " << endl;
                }
            }
        }
    }
    
    //Correlation Function - Snapshot
    for(int count = 0; count < MCP.cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Current Snapshot, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << OP.corrFunc[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << OP.ECorrFunc[count] << endl;
    }
    //TB
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << OP.TBCorrFunc[count] << endl;
    }
    //AB
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Current Snapshot, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << OP.ABCorrFunc[count] << endl;
    }
    
    
    //Correlation function - SumChar
    for(int count = 0; count < MCP.cellsA*2; count++){
        for(int i = 0; i < NUMVECTORS; i++){
            for(int j = 0; j < TYPESOP; j++){
                stream << "Sum over Configurations, Correlation Function - ";
                stream << "between " << count << " Nearest Neighbors - ";
                stream << charOPNames[i][j] << ": " << LC.sumOPCorrFunc[i][j][count] << endl;
            }
        }
    }
    //E
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Energy to the 1st power: " << LC.sumECorrFunc[count] << endl;
    }
    //TB
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Polar Angle to B Field to the 1st power: " << LC.sumTBCorrFunc[count] << endl;
    }
    //AB
    for(int count = 0; count < MCP.cellsA*2; count++){
        stream << "Sum over Configurations, Correlation Function - ";
        stream << "between " << count << " Nearest Neighbors - ";
        stream << "Azimuthal Angle to the B Field to the 1st power: " << LC.sumABCorrFunc[count] << endl;
    }
    
    
    return stream.str();
}


void MonteCarlo::metropolisSweep(){
    double   changeInEnergy  = 0;
    double   initialEnergy   = 0;
    double   finalEnergy     = 0;
    
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < MCP.cellsC; z++)
                {
                    if(MCP.isDomainWalls){
                        if(
                           isDomain(i, j, k, z, MCP.cellsA/2)||
                           isDomain(i, j, k, z, MCP.cellsA/2 -1)
                           ){
                            continue;
                        }
                    }
                    //getSpin(i, j, k).checkSpin();
                    initialEnergy = getLocalEnergy(lattice[i][j][k][z] , true);
                    lattice[i][j][k][z].flip(MD.range);
                    finalEnergy = getLocalEnergy(lattice[i][j][k][z], true);
                    changeInEnergy = finalEnergy - initialEnergy;
                    MD.flipAttempts += 1;
                    MD.successfulFlips += 1;
                    //The lattice automatically keeps the spin flip unless the
                    //energy is > 0
                    
                    if(changeInEnergy > 0)
                    {
                        /**
                         *Then it keeps the flip if a function f(KbT, delta_E) is
                         *less than a certain probability (0,1).
                         */
                        if(drand48() >= exp((-1) * (1.0/MCP.KbT) * changeInEnergy))
                        {
                            
                            //resets spin
                            lattice[i][j][k][z].reset();
                            MD.successfulFlips -= 1;
                        }
                        else
                        {
                            //Keeps Spin flip if rand < exp()
                        }
                    }
                    else if(changeInEnergy == 0 && initialEnergy == 0)
                    {
                        //resets spin
                        lattice[i][j][k][z].reset();
                        MD.successfulFlips -= 1;
                    }
                }
            }
        }
    }
}

bool MonteCarlo::thermalize(double KbT_, int numSweepsToDo, double durationOfSingleRun){
    
    double oldKbT = MCP.KbT;
    MCP.KbT = KbT_;
    
    if(MCP.isDomainWalls){
        SetDomainWall();
    }
    
    for(int sweeps = MD.numSweepsUsedToThermalize; sweeps <= numSweepsToDo; sweeps++){
        int clocks = clock() - MD.timeOfInitialization;
        double hoursElapsed = clocks * (1.0/(CLOCKS_PER_SEC*1.0)) / (60 * 60);
        if(hoursElapsed > durationOfSingleRun){
            break;
        }
        
        metropolisSweep();
        MD.numSweepsPerformed += 1;
        MD.numSweepsUsedToThermalize += 1;
        adjustRange();
        
        
    }
    
    MCP.KbT = oldKbT;
    
    if(MD.numSweepsUsedToThermalize >= numSweepsToDo){
        cout<<"Returning from Thermalize. Finished."<<endl;
        return false;
    }
    
    cout<<"Returning from Thermalize. Out of Time."<<endl;
    return true;//true if out of time.
}

bool MonteCarlo::isThermalized(double durationOfSingleRun){//return true if out of time.
    
    if(MCP.isDomainWalls){
        SetDomainWall();
    }
    
    for(int i = 0; i < 10; i++){
        metropolisSweep();
        MD.numSweepsPerformed += 1;
        MD.numSweepsUsedToThermalize += 1;
        adjustRange();
        addToMagStats();//This function is the only place this is called except sweep()
        MD.numSweepsPerformedToCheckIfThermalized += 1;
    }
    
    bool outOfTime = false;
    int thermalCycles = -1;
    while(!outOfTime){
        thermalCycles ++;
        cout<<"Thermal Cycle # " << thermalCycles<<endl;
        
        double clocks = clock() - MD.timeOfInitialization;
        double hoursElapsed = clocks * (1.0/(CLOCKS_PER_SEC*1.0)) / (60 * 60);
        if(hoursElapsed > durationOfSingleRun){
            outOfTime = true;
            return outOfTime;
        }
        
        LatticeCharacteristics firstLC = LC;
        
        int numSweepsAveOver = (int) (2000);
        for(int i = 0; i < numSweepsAveOver; i++){
            metropolisSweep();
            MD.numSweepsPerformed += 1;
            MD.numSweepsUsedToThermalize += 1;
            adjustRange();
            addToMagStats();
            MD.numSweepsPerformedToCheckIfThermalized += 1;
        }
        
        LatticeCharacteristics secLC = LC;
        
        double firstBinder = 0;
        double secBinder = 0;
        bool smallDiffBinder = true;
        for(int i = 0; i < NUMVECTORS; i++){
            double m4_1 = firstLC.sumOP[i][0][3] / (MD.numSweepsPerformedToCheckIfThermalized - numSweepsAveOver);
            double m2_1 = firstLC.sumOP[i][0][1] / (MD.numSweepsPerformedToCheckIfThermalized - numSweepsAveOver);
            double m4_2 = secLC.sumOP[i][0][3] / (MD.numSweepsPerformedToCheckIfThermalized);
            double m2_2 = secLC.sumOP[i][0][1] / (MD.numSweepsPerformedToCheckIfThermalized);
            
            firstBinder = 1.0 - m4_1/ (3.0 * m2_1 * m2_1);
            
            secBinder = 1.0 - m4_2/ (3.0 * m2_2 * m2_2);
            
            cout<<"Is Thermal? Diff is: "<<fabs(firstBinder - secBinder)<<endl;
            if(fabs(firstBinder - secBinder) > 1e-2){
                smallDiffBinder = false;
                break;
            }
            
        }
        
        if(smallDiffBinder){// thermalized.
            setLCToZero();
            setOPToZero();
            setRecipToZero();
            
            double range_t = MD.range;
            double rangeOld_t =  MD.rangeOld;
            int numSweepsPerformed_t =  MD.numSweepsPerformed;
            int numSweepsUsedToThermalize_t =  MD.numSweepsUsedToThermalize;
            clock_t timeOfInitialization_t =  MD.timeOfInitialization;
            
            setMDToZero();
            
            MD.range = range_t;
            MD.rangeOld = rangeOld_t;
            MD.numSweepsPerformed = numSweepsPerformed_t;
            MD.numSweepsUsedToThermalize = numSweepsUsedToThermalize_t;
            MD.timeOfInitialization = timeOfInitialization_t;
            MD.isThermal = true;
            
            cout<<"Returning from isThermalized. Not Out of Time."<<endl;
            return outOfTime;
        }
    }
    
    
    return outOfTime;
}

void MonteCarlo::adjustRange(){
    
    double goal = 0.65;
    double successRate = MD.successfulFlips / (MD.flipAttempts * 1.0);
    double diff = successRate - goal;
    if(fabs(diff) < 0.01){
        return;
    }
    
    /**
     *This uses a binary search to change the range of the spin flips until
     *the rate of successful flips is ~goal.
     */
    double temp = fabs(MD.range - MD.rangeOld) / 2.0;
    if(temp == 0){temp = 0.1;}
    
    MD.rangeOld = MD.range;
    if(diff > 0){
        MD.range += temp;
        if(MD.range > PI){
            MD.range = PI;
            return;
        }
    }else{
        MD.range -= temp;
        if(MD.range < 0.01){
            MD.range = 0.01;
            return;
        }
    }
    MD.successfulFlips = 0;
    MD.flipAttempts = 0;
}

void MonteCarlo::updateOrderParameters(){
    
    double E = 0;
    double X = 0;
    double Y = 0;
    double Z = 0;
    //double XY = 0;
    //double YZ = 0;
    //double ZX = 0;
    //double PX = 0;
    //double PY = 0;
    //double PZ = 0;
    double M[SPINDIMEN] = {0};
    double N[SPINDIMEN] = {0};
    double S1[SPINDIMEN] = {0};
    double S2[SPINDIMEN] = {0};
    double S3[SPINDIMEN] = {0};
    double N3D[SPINDIMEN] = {0};
    double ZZ1[SPINDIMEN] = {0};
    double ZZ2[SPINDIMEN] = {0};
    double ZZ3[SPINDIMEN] = {0};
    
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    
                    X = lattice[i][j][k][z].getX();
                    Y = lattice[i][j][k][z].getY();
                    Z = lattice[i][j][k][z].getZ();
                    //XY = X * Y;
                    //YZ = Y * Z;
                    //ZX = Z * X;
                    //PX = sqrt(2.0) * 0.5 * (2.0 * XY - YZ - ZX);
                    //PY = sqrt(6.0) * 0.5 * (YZ - ZX);
                    //PZ = XY + YZ + ZX;
                    
                    //OP: E
                    E += getLocalEnergy(lattice[i][j][k][z], false);
                    //End OP: E
                    
                    //OP: M
                    M[0] += X;
                    M[1] += Y;
                    M[2] += Z;
                    //M[3] += XY;
                    //M[4] += YZ;
                    //M[5] += ZX;
                    //M[6] += PX;
                    //M[7] += PY;
                    //M[8] += PZ;
                    //End OP: M
                    
                    //OP: N
                    //if k == 0 - count negative M, k == 1 - positive M
                    N[0] += (2 * k - 1) * X;
                    N[1] += (2 * k - 1) * Y;
                    N[2] += (2 * k - 1) * Z;
                    //N[3] += (2 * k - 1) * XY;
                    //N[4] += (2 * k - 1) * YZ;
                    //N[5] += (2 * k - 1) * ZX;
                    //N[6] += (2 * k - 1) * PX;
                    //N[7] += (2 * k - 1) * PY;
                    //N[8] += (2 * k - 1) * PZ;
                    //End OP: N
                    
                    //OP: S1
                    //along perp-y axis (ferro exchange along y direction)
                    if((i % 2 == 0) && (j % 2 == 0) && (k == 1)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        //S1[3] += XY;
                        //S1[4] += YZ;
                        //S1[5] += ZX;
                        //S1[6] += PX;
                        //S1[7] += PY;
                        //S1[8] += PZ;
                    }else if((i % 2 == 1) && (j % 2 == 1) && (k == 1)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        //S1[3] += XY;
                        //S1[4] += YZ;
                        //S1[5] += ZX;
                        //S1[6] += PX;
                        //S1[7] += PY;
                        //S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 1) && (k == 1)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        //S1[3] += (-1) * XY;
                        //S1[4] += (-1) * YZ;
                        //S1[5] += (-1) * ZX;
                        //S1[6] += (-1) * PX;
                        //S1[7] += (-1) * PY;
                        //S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 0) && (k == 1)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        //S1[3] += (-1) * XY;
                        //S1[4] += (-1) * YZ;
                        //S1[5] += (-1) * ZX;
                        //S1[6] += (-1) * PX;
                        //S1[7] += (-1) * PY;
                        //S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 0) && (k == 0)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        //S1[3] += XY;
                        //S1[4] += YZ;
                        //S1[5] += ZX;
                        //S1[6] += PX;
                        //S1[7] += PY;
                        //S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 1) && (k == 0)){
                        S1[0] += X;
                        S1[1] += Y;
                        S1[2] += Z;
                        //S1[3] += XY;
                        //S1[4] += YZ;
                        //S1[5] += ZX;
                        //S1[6] += PX;
                        //S1[7] += PY;
                        //S1[8] += PZ;
                    }else if((i % 2 == 0) && (j % 2 == 0) && (k == 0)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        //S1[3] += (-1) * XY;
                        //S1[4] += (-1) * YZ;
                        //S1[5] += (-1) * ZX;
                        //S1[6] += (-1) * PX;
                        //S1[7] += (-1) * PY;
                        //S1[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (j % 2 == 1) && (k == 0)){
                        S1[0] += (-1) * X;
                        S1[1] += (-1) * Y;
                        S1[2] += (-1) * Z;
                        //S1[3] += (-1) * XY;
                        //S1[4] += (-1) * YZ;
                        //S1[5] += (-1) * ZX;
                        //S1[6] += (-1) * PX;
                        //S1[7] += (-1) * PY;
                        //S1[8] += (-1) * PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S1
                    
                    //OP: S2
                    //along y axis (ferro exchange along x direction)
                    if((i % 2 == 0) && (k == 1)){
                        S2[0] += X;
                        S2[1] += Y;
                        S2[2] += Z;
                        //S2[3] += XY;
                        //S2[4] += YZ;
                        //S2[5] += ZX;
                        //S2[6] += PX;
                        //S2[7] += PY;
                        //S2[8] += PZ;
                    }else if((i % 2 == 1) && (k == 1)){
                        S2[0] += (-1) * X;
                        S2[1] += (-1) * Y;
                        S2[2] += (-1) * Z;
                        //S2[3] += (-1) * XY;
                        //S2[4] += (-1) * YZ;
                        //S2[5] += (-1) * ZX;
                        //S2[6] += (-1) * PX;
                        //S2[7] += (-1) * PY;
                        //S2[8] += (-1) * PZ;
                    }else if((i % 2 == 0) && (k == 0)){
                        S2[0] += (-1) * X;
                        S2[1] += (-1) * Y;
                        S2[2] += (-1) * Z;
                        //S2[3] += (-1) * XY;
                        //S2[4] += (-1) * YZ;
                        //S2[5] += (-1) * ZX;
                        //S2[6] += (-1) * PX;
                        //S2[7] += (-1) * PY;
                        //S2[8] += (-1) * PZ;
                    }else if((i % 2 == 1) && (k == 0)){
                        S2[0] += X;
                        S2[1] += Y;
                        S2[2] += Z;
                        //S2[3] += XY;
                        //S2[4] += YZ;
                        //S2[5] += ZX;
                        //S2[6] += PX;
                        //S2[7] += PY;
                        //S2[8] += PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S2
                    
                    //OP: S3
                    //along x axis (ferro exchange along z direction)
                    if(j % 2 == 0){
                        S3[0] += X;
                        S3[1] += Y;
                        S3[2] += Z;
                        //S3[3] += XY;
                        //S3[4] += YZ;
                        //S3[5] += ZX;
                        //S3[6] += PX;
                        //S3[7] += PY;
                        //S3[8] += PZ;
                    }else if(j % 2 == 1){
                        S3[0] += (-1) * X;
                        S3[1] += (-1) * Y;
                        S3[2] += (-1) * Z;
                        //S3[3] += (-1) * XY;
                        //S3[4] += (-1) * YZ;
                        //S3[5] += (-1) * ZX;
                        //S3[6] += (-1) * PX;
                        //S3[7] += (-1) * PY;
                        //S3[8] += (-1) * PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: S3
                    
                    //OP: N3D
                    //if k == 0 - count negative M, k == 1 - positive M
                    if(z % 2 == 0){
                        N3D[0] += (2 * k - 1) * X;
                        N3D[1] += (2 * k - 1) * Y;
                        N3D[2] += (2 * k - 1) * Z;
                        //N3D[3] += (2 * k - 1) * XY;
                        //N3D[4] += (2 * k - 1) * YZ;
                        //N3D[5] += (2 * k - 1) * ZX;
                        //N3D[6] += (2 * k - 1) * PX;
                        //N3D[7] += (2 * k - 1) * PY;
                        //N3D[8] += (2 * k - 1) * PZ;
                    }else if(z % 2 == 1){
                        //Alternatively vertically, count negative M.
                        N3D[0] += (-1) * (2 * k - 1) * X;
                        N3D[1] += (-1) * (2 * k - 1) * Y;
                        N3D[2] += (-1) * (2 * k - 1) * Z;
                        //N3D[3] += (-1) * (2 * k - 1) * XY;
                        //N3D[4] += (-1) * (2 * k - 1) * YZ;
                        //N3D[5] += (-1) * (2 * k - 1) * ZX;
                        //N3D[6] += (-1) * (2 * k - 1) * PX;
                        //N3D[7] += (-1) * (2 * k - 1) * PY;
                        //N3D[8] += (-1) * (2 * k - 1) * PZ;
                    }else{
                        cerr << "shouldn't happen" << endl;
                        exit(3161990);
                    }
                    //End OP: N3D
                    
                    //OP: ZZ1 (Zig Zag) along x axis
                    if((j % 2 == 0) && (k == 1)){
                        ZZ1[0] += X;
                        ZZ1[1] += Y;
                        ZZ1[2] += Z;
                        //ZZ1[3] += XY;
                        //ZZ1[4] += YZ;
                        //ZZ1[5] += ZX;
                        //ZZ1[6] += PX;
                        //ZZ1[7] += PY;
                        //ZZ1[8] += PZ;
                    }else if((j % 2 == 1) && (k == 1)){
                        ZZ1[0] += (-1) * X;
                        ZZ1[1] += (-1) * Y;
                        ZZ1[2] += (-1) * Z;
                        //ZZ1[3] += (-1) * XY;
                        //ZZ1[4] += (-1) * YZ;
                        //ZZ1[5] += (-1) * ZX;
                        //ZZ1[6] += (-1) * PX;
                        //ZZ1[7] += (-1) * PY;
                        //ZZ1[8] += (-1) * PZ;
                    }else if((j % 2 == 0) && (k == 0)){
                        ZZ1[0] += (-1) * X;
                        ZZ1[1] += (-1) * Y;
                        ZZ1[2] += (-1) * Z;
                        //ZZ1[3] += (-1) * XY;
                        //ZZ1[4] += (-1) * YZ;
                        //ZZ1[5] += (-1) * ZX;
                        //ZZ1[6] += (-1) * PX;
                        //ZZ1[7] += (-1) * PY;
                        //ZZ1[8] += (-1) * PZ;
                    }else if((j % 2 == 1) && (k == 0)){
                        ZZ1[0] += X;
                        ZZ1[1] += Y;
                        ZZ1[2] += Z;
                        //ZZ1[3] += XY;
                        //ZZ1[4] += YZ;
                        //ZZ1[5] += ZX;
                        //ZZ1[6] += PX;
                        //ZZ1[7] += PY;
                        //ZZ1[8] += PZ;
                    }else{
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ1
                    
                    //OP: ZZ2 (Zig Zag) - along Y axis
                    if((i % 2 == 0))
                    {
                        ZZ2[0] += (-1) * X;
                        ZZ2[1] += (-1) * Y;
                        ZZ2[2] += (-1) * Z;
                        //ZZ2[3] += (-1) * XY;
                        //ZZ2[4] += (-1) * YZ;
                        //ZZ2[5] += (-1) * ZX;
                        //ZZ2[6] += (-1) * PX;
                        //ZZ2[7] += (-1) * PY;
                        //ZZ2[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1))
                    {
                        ZZ2[0] += X;
                        ZZ2[1] += Y;
                        ZZ2[2] += Z;
                        //ZZ2[3] += XY;
                        //ZZ2[4] += YZ;
                        //ZZ2[5] += ZX;
                        //ZZ2[6] += PX;
                        //ZZ2[7] += PY;
                        //ZZ2[8] += PZ;
                    }
                    else
                    {
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ2
                    
                    //OP: ZZ3 (Zig Zag) - perp to y axis (along
                    if((i % 2 == 0) && (j % 2 == 0))
                    {
                        ZZ3[0] += X;
                        ZZ3[1] += Y;
                        ZZ3[2] += Z;
                        //ZZ3[3] += XY;
                        //ZZ3[4] += YZ;
                        //ZZ3[5] += ZX;
                        //ZZ3[6] += PX;
                        //ZZ3[7] += PY;
                        //ZZ3[8] += PZ;
                    }
                    else if((i % 2 == 0) && (j % 2 == 1))
                    {
                        ZZ3[0] += (-1) * X;
                        ZZ3[1] += (-1) * Y;
                        ZZ3[2] += (-1) * Z;
                        //ZZ3[3] += (-1) * XY;
                        //ZZ3[4] += (-1) * YZ;
                        //ZZ3[5] += (-1) * ZX;
                        //ZZ3[6] += (-1) * PX;
                        //ZZ3[7] += (-1) * PY;
                        //ZZ3[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1) && (j % 2 == 0))
                    {
                        ZZ3[0] += (-1) * X;
                        ZZ3[1] += (-1) * Y;
                        ZZ3[2] += (-1) * Z;
                        //ZZ3[3] += (-1) * XY;
                        //ZZ3[4] += (-1) * YZ;
                        //ZZ3[5] += (-1) * ZX;
                        //ZZ3[6] += (-1) * PX;
                        //ZZ3[7] += (-1) * PY;
                        //ZZ3[8] += (-1) * PZ;
                    }
                    else if((i % 2 == 1) && (j % 2 == 1))
                    {
                        ZZ3[0] += X;
                        ZZ3[1] += Y;
                        ZZ3[2] += Z;
                        //ZZ3[3] += XY;
                        //ZZ3[4] += YZ;
                        //ZZ3[5] += ZX;
                        //ZZ3[6] += PX;
                        //ZZ3[7] += PY;
                        //ZZ3[8] += PZ;
                    }
                    else
                    {
                        std::cerr << "Shouldn't occur" << std::endl;
                        exit(1);
                    }
                    //End OP: ZZ3
                    
                    
                    
                }
            }
        }
    }
    //End OP
    
    //OP: TB, Polar Angle to B Field
    OP.TB = getPolarAngleTB(M[0], M[1], M[2]);
    
    //OP: AB, Azimuthal Angle to the B Field
    OP.AB = getAziAngleAB(M[0], M[1], M[2]);
    
    OP.E = E; //Total E, E not per site
    
    //All Order parameters are per site
    const double numSites = MCP.cellsA * MCP.cellsB * MCP.cellsC * 2.0;
    
    for(int i = 0; i < SPINDIMEN; i++){
        M[i] = M[i] / numSites;
        N[i] = N[i] / numSites;
        S1[i] = S1[i] / numSites;
        S2[i] = S2[i] / numSites;
        S3[i] = S3[i] / numSites;
        N3D[i] = N3D[i] / numSites;
        ZZ1[i] = ZZ1[i] / numSites;
        ZZ2[i] = ZZ2[i] / numSites;
        ZZ3[i] = ZZ3[i] / numSites;
    }
    
    //Now to calculate the characteristics of the order parameters.
    double OPArr[NUMVECTORS][SPINDIMEN] = {0};
    for(int i = 0; i < SPINDIMEN; i++){
        OPArr[0][i] = M[i];
        OPArr[1][i] = N[i];
        OPArr[2][i] = S1[i];
        OPArr[3][i] = S2[i];
        OPArr[4][i] = S3[i];
        OPArr[5][i] = sqrt(S1[i]*S1[i] + S2[i]*S2[i] + S3[i]*S3[i]);
        OPArr[6][i] = N3D[i];
        OPArr[7][i] = ZZ1[i];
        OPArr[8][i] = ZZ2[i];
        OPArr[9][i] = ZZ3[i];
        OPArr[10][i] = sqrt(ZZ1[i]*ZZ1[i] + ZZ2[i]*ZZ2[i] + ZZ3[i]*ZZ3[i]);
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        
        const double a1 = 0;
        const double a2 = PI/3.0;
        const double a3 = 2*PI/3.0;
        const double a4 = PI;
        const double a5 = 4*PI/3.0;
        const double a6 = 5*PI/3.0;
        
        //Scalar quantity eg. M
        OP.charOP[i][0] = sqrt(OPArr[i][0]*OPArr[i][0] +
                               OPArr[i][1]*OPArr[i][1] +
                               OPArr[i][2]*OPArr[i][2]);
        
        /*
         double tempB1 = (OP.snapOP[i][0]*OP.snapOP[i][0] +
         OP.snapOP[i][1]*OP.snapOP[i][1] -
         2*OP.snapOP[i][2]*OP.snapOP[i][2])/sqrt(6.0);
         
         double tempB2 = (OP.snapOP[i][0]*OP.snapOP[i][0] -
         OP.snapOP[i][1]*OP.snapOP[i][1])/sqrt(2.0);
         */
        
        //OP.charOP[i][1] = 0;
        //OP.charOP[i][2] = 0;
        
        OP.charOP[i][1] = fabs(OPArr[i][0])*cos(a1);
        OP.charOP[i][2] = fabs(OPArr[i][0])*sin(a1);
        
        OP.charOP[i][1] += fabs(OPArr[i][1])*cos(a3);
        OP.charOP[i][2] += fabs(OPArr[i][1])*sin(a3);
        
        OP.charOP[i][1] += fabs(OPArr[i][2])*cos(a5);
        OP.charOP[i][2] += fabs(OPArr[i][2])*sin(a5);
        
        //sqrt(b1*b1 + b2*b2)
        OP.charOP[i][3] = sqrt(OP.charOP[i][1]*OP.charOP[i][1] +
                               OP.charOP[i][2]*OP.charOP[i][2]);
        
        //m
        //m1
        OP.charOP[i][4] = 0;
        
        //m2
        OP.charOP[i][5] = 0;
        
        if(OPArr[i][0] > 0){
            OP.charOP[i][4] += fabs(OPArr[i][0])*cos(a2);
            OP.charOP[i][5] += fabs(OPArr[i][0])*sin(a2);
        }else{
            OP.charOP[i][4] += fabs(OPArr[i][0])*cos(a5);
            OP.charOP[i][5] += fabs(OPArr[i][0])*sin(a5);
        }
        
        if(OPArr[i][1] > 0){
            OP.charOP[i][4] += fabs(OPArr[i][1])*cos(a1);
            OP.charOP[i][5] += fabs(OPArr[i][1])*sin(a1);
        }else{
            OP.charOP[i][4] += fabs(OPArr[i][1])*cos(a4);
            OP.charOP[i][5] += fabs(OPArr[i][1])*sin(a4);
        }
        
        if(OPArr[i][2] > 0){
            OP.charOP[i][4] += fabs(OPArr[i][2])*cos(a6);
            OP.charOP[i][5] += fabs(OPArr[i][2])*sin(a6);
        }else{
            OP.charOP[i][4] += fabs(OPArr[i][2])*cos(a3);
            OP.charOP[i][5] += fabs(OPArr[i][2])*sin(a3);
        }
        
        
        
        //sqrt(m1*m1 + m2*m2)
        OP.charOP[i][6] = sqrt(OP.charOP[i][4]*OP.charOP[i][4] +
                               OP.charOP[i][5]*OP.charOP[i][5]);
        
        //fabs x, y, z, directions
        OP.charOP[i][7] = fabs(OPArr[i][0]);
        
        OP.charOP[i][8] = fabs(OPArr[i][1]);
        
        OP.charOP[i][9] = fabs(OPArr[i][2]);
        
        //OP.charOP[i][10] = OPArr[i][3];
        
        //OP.charOP[i][11] = OPArr[i][4];
        
        //OP.charOP[i][12] = OPArr[i][5];
        
        //OP.charOP[i][13] = OPArr[i][6];
        
        //OP.charOP[i][14] = OPArr[i][7];
        
        //OP.charOP[i][15] = OPArr[i][8];
        
        //OP.charOP[i][16] = sqrt(OPArr[i][6] * OPArr[i][6] +
        //                        OPArr[i][7] * OPArr[i][7] +
        //                        OPArr[i][8] * OPArr[i][8]);
        
        
    }
    
    if((MD.numConfigsDone % CORRTOUPDATES == 0)&&(MD.numConfigsDone > 0)){
        updateCorrelationFunction();
    }
    
    if((MD.numConfigsDone % FTTOUPDATES == 0)&&(MD.numConfigsDone > 0)){
        updateFourierTransformOnRecipLattice();
    }
    
}

void MonteCarlo::updateCorrelationFunction(){
    
    double E[NUMCORRSPINSBIG] = {0};
    double TB[NUMCORRSPINSBIG] = {0};
    double AB[NUMCORRSPINSBIG] = {0};
    double X = 0;
    double Y = 0;
    double Z = 0;
    //double XY = 0;
    //double YZ = 0;
    //double ZX = 0;
    //double PX = 0;
    //double PY = 0;
    //double PZ = 0;
    double M[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double N[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S1[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S2[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double S3[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double N3D[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ1[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ2[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    double ZZ3[SPINDIMEN][NUMCORRSPINSBIG] = {0};
    
    int j = -1;//To start on zero for count = 0.
    int i = 0;
    int k = 0;
    int z = 0;
    
    for(int count = 0; count < 2*MCP.cellsA; count++){
        
        //This control structure picks the diagonal spins out across the lattice.
        if(count % 2 == 0 ){
            k = 0;
        }else{
            k = 1;
        }
        
        if(count % 4 == 0 ){
            i = i + 0;
        }else if(count % 4 == 1 ){
            i = i + 0;
        }else if(count % 4 == 2 ){
            i = i + 0;
        }else{
            i = i + 1;
        }
        
        if(count % 4 == 0 ){
            j = j + 1;
        }else if(count % 4 == 1 ){
            j = j + 0;
        }else if(count % 4 == 2 ){
            j = j + 1;
        }else{
            j = j - 1;
        }
        
        z = 0;
        
        //OP: E
        E[count] = getLocalEnergy(lattice[i][j][k][z], false);
        //End OP: E
        
        
        X = lattice[i][j][k][z].getX();
        Y = lattice[i][j][k][z].getY();
        Z = lattice[i][j][k][z].getZ();
        //XY = X * Y;
        //YZ = Y * Z;
        //ZX = Z * X;
        //PX = sqrt(2.0) * 0.5 * (2.0 * XY - YZ - ZX);
        //PY = sqrt(6.0) * 0.5 * (YZ - ZX);
        //PZ = XY + YZ + ZX;
        
        //OP: M
        M[0][count] += X;
        M[1][count] += Y;
        M[2][count] += Z;
        //M[3][count] += XY;
        //M[4][count] += YZ;
        //M[5][count] += ZX;
        //M[6][count] += PX;
        //M[7][count] += PY;
        //M[8][count] += PZ;
        //End OP: M
        
        //OP: N
        //if k == 0 - count negative M, k == 1 - positive M
        N[0][count] += (2 * k - 1) * X;
        N[1][count] += (2 * k - 1) * Y;
        N[2][count] += (2 * k - 1) * Z;
        //N[3][count] += (2 * k - 1) * XY;
        //N[4][count] += (2 * k - 1) * YZ;
        //N[5][count] += (2 * k - 1) * ZX;
        //N[6][count] += (2 * k - 1) * PX;
        //N[7][count] += (2 * k - 1) * PY;
        //N[8][count] += (2 * k - 1) * PZ;
        //End OP: N
        
        //OP: S1
        //along perp-y axis (ferro exchange along y direction)
        if((i % 2 == 0) && (j % 2 == 0) && (k == 1)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            //S1[3][count] += XY;
            //S1[4][count] += YZ;
            //S1[5][count] += ZX;
            //S1[6][count] += PX;
            //S1[7][count] += PY;
            //S1[8][count] += PZ;
        }else if((i % 2 == 1) && (j % 2 == 1) && (k == 1)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            //S1[3][count] += XY;
            //S1[4][count] += YZ;
            //S1[5][count] += ZX;
            //S1[6][count] += PX;
            //S1[7][count] += PY;
            //S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 1) && (k == 1)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            //S1[3][count] += (-1) * XY;
            //S1[4][count] += (-1) * YZ;
            //S1[5][count] += (-1) * ZX;
            //S1[6][count] += (-1) * PX;
            //S1[7][count] += (-1) * PY;
            //S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 0) && (k == 1)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            //S1[3][count] += (-1) * XY;
            //S1[4][count] += (-1) * YZ;
            //S1[5][count] += (-1) * ZX;
            //S1[6][count] += (-1) * PX;
            //S1[7][count] += (-1) * PY;
            //S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 0) && (k == 0)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            //S1[3][count] += XY;
            //S1[4][count] += YZ;
            //S1[5][count] += ZX;
            //S1[6][count] += PX;
            //S1[7][count] += PY;
            //S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 1) && (k == 0)){
            S1[0][count] += X;
            S1[1][count] += Y;
            S1[2][count] += Z;
            //S1[3][count] += XY;
            //S1[4][count] += YZ;
            //S1[5][count] += ZX;
            //S1[6][count] += PX;
            //S1[7][count] += PY;
            //S1[8][count] += PZ;
        }else if((i % 2 == 0) && (j % 2 == 0) && (k == 0)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            //S1[3][count] += (-1) * XY;
            //S1[4][count] += (-1) * YZ;
            //S1[5][count] += (-1) * ZX;
            //S1[6][count] += (-1) * PX;
            //S1[7][count] += (-1) * PY;
            //S1[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (j % 2 == 1) && (k == 0)){
            S1[0][count] += (-1) * X;
            S1[1][count] += (-1) * Y;
            S1[2][count] += (-1) * Z;
            //S1[3][count] += (-1) * XY;
            //S1[4][count] += (-1) * YZ;
            //S1[5][count] += (-1) * ZX;
            //S1[6][count] += (-1) * PX;
            //S1[7][count] += (-1) * PY;
            //S1[8][count] += (-1) * PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S1
        
        //OP: S2
        //along y axis (ferro exchange along x direction)
        if((i % 2 == 0) && (k == 1)){
            S2[0][count] += X;
            S2[1][count] += Y;
            S2[2][count] += Z;
            //S2[3][count] += XY;
            //S2[4][count] += YZ;
            //S2[5][count] += ZX;
            //S2[6][count] += PX;
            //S2[7][count] += PY;
            //S2[8][count] += PZ;
        }else if((i % 2 == 1) && (k == 1)){
            S2[0][count] += (-1) * X;
            S2[1][count] += (-1) * Y;
            S2[2][count] += (-1) * Z;
            //S2[3][count] += (-1) * XY;
            //S2[4][count] += (-1) * YZ;
            //S2[5][count] += (-1) * ZX;
            //S2[6][count] += (-1) * PX;
            //S2[7][count] += (-1) * PY;
            //S2[8][count] += (-1) * PZ;
        }else if((i % 2 == 0) && (k == 0)){
            S2[0][count] += (-1) * X;
            S2[1][count] += (-1) * Y;
            S2[2][count] += (-1) * Z;
            //S2[3][count] += (-1) * XY;
            //S2[4][count] += (-1) * YZ;
            //S2[5][count] += (-1) * ZX;
            //S2[6][count] += (-1) * PX;
            //S2[7][count] += (-1) * PY;
            //S2[8][count] += (-1) * PZ;
        }else if((i % 2 == 1) && (k == 0)){
            S2[0][count] += X;
            S2[1][count] += Y;
            S2[2][count] += Z;
            //S2[3][count] += XY;
            //S2[4][count] += YZ;
            //S2[5][count] += ZX;
            //S2[6][count] += PX;
            //S2[7][count] += PY;
            //S2[8][count] += PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S2
        
        //OP: S3
        //along x axis (ferro exchange along z direction)
        if(j % 2 == 0){
            S3[0][count] += X;
            S3[1][count] += Y;
            S3[2][count] += Z;
            //S3[3][count] += XY;
            //S3[4][count] += YZ;
            //S3[5][count] += ZX;
            //S3[6][count] += PX;
            //S3[7][count] += PY;
            //S3[8][count] += PZ;
        }else if(j % 2 == 1){
            S3[0][count] += (-1) * X;
            S3[1][count] += (-1) * Y;
            S3[2][count] += (-1) * Z;
            //S3[3][count] += (-1) * XY;
            //S3[4][count] += (-1) * YZ;
            //S3[5][count] += (-1) * ZX;
            //S3[6][count] += (-1) * PX;
            //S3[7][count] += (-1) * PY;
            //S3[8][count] += (-1) * PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: S3
        
        //OP: N3D
        //if k == 0 - count negative M, k == 1 - positive M
        if(z % 2 == 0){
            N3D[0][count] += (2 * k - 1) * X;
            N3D[1][count] += (2 * k - 1) * Y;
            N3D[2][count] += (2 * k - 1) * Z;
            //N3D[3][count] += (2 * k - 1) * XY;
            //N3D[4][count] += (2 * k - 1) * YZ;
            //N3D[5][count] += (2 * k - 1) * ZX;
            //N3D[6][count] += (2 * k - 1) * PX;
            //N3D[7][count] += (2 * k - 1) * PY;
            //N3D[8][count] += (2 * k - 1) * PZ;
        }else if(z % 2 == 1){
            //Alternatively vertically, count negative M.
            N3D[0][count] += (-1) * (2 * k - 1) * X;
            N3D[1][count] += (-1) * (2 * k - 1) * Y;
            N3D[2][count] += (-1) * (2 * k - 1) * Z;
            //N3D[3][count] += (-1) * (2 * k - 1) * XY;
            //N3D[4][count] += (-1) * (2 * k - 1) * YZ;
            //N3D[5][count] += (-1) * (2 * k - 1) * ZX;
            //N3D[6][count] += (-1) * (2 * k - 1) * PX;
            //N3D[7][count] += (-1) * (2 * k - 1) * PY;
            //N3D[8][count] += (-1) * (2 * k - 1) * PZ;
        }else{
            cerr << "shouldn't happen" << endl;
            exit(3161990);
        }
        //End OP: N3D
        
        //OP: ZZ1 (Zig Zag) along x axis
        if((j % 2 == 0) && (k == 1)){
            ZZ1[0][count] += X;
            ZZ1[1][count] += Y;
            ZZ1[2][count] += Z;
            //ZZ1[3][count] += XY;
            //ZZ1[4][count] += YZ;
            //ZZ1[5][count] += ZX;
            //ZZ1[6][count] += PX;
            //ZZ1[7][count] += PY;
            //ZZ1[8][count] += PZ;
        }else if((j % 2 == 1) && (k == 1)){
            ZZ1[0][count] += (-1) * X;
            ZZ1[1][count] += (-1) * Y;
            ZZ1[2][count] += (-1) * Z;
            //ZZ1[3][count] += (-1) * XY;
            //ZZ1[4][count] += (-1) * YZ;
            //ZZ1[5][count] += (-1) * ZX;
            //ZZ1[6][count] += (-1) * PX;
            //ZZ1[7][count] += (-1) * PY;
            //ZZ1[8][count] += (-1) * PZ;
        }else if((j % 2 == 0) && (k == 0)){
            ZZ1[0][count] += (-1) * X;
            ZZ1[1][count] += (-1) * Y;
            ZZ1[2][count] += (-1) * Z;
            //ZZ1[3][count] += (-1) * XY;
            //ZZ1[4][count] += (-1) * YZ;
            //ZZ1[5][count] += (-1) * ZX;
            //ZZ1[6][count] += (-1) * PX;
            //ZZ1[7][count] += (-1) * PY;
            //ZZ1[8][count] += (-1) * PZ;
        }else if((j % 2 == 1) && (k == 0)){
            ZZ1[0][count] += X;
            ZZ1[1][count] += Y;
            ZZ1[2][count] += Z;
            //ZZ1[3][count] += XY;
            //ZZ1[4][count] += YZ;
            //ZZ1[5][count] += ZX;
            //ZZ1[6][count] += PX;
            //ZZ1[7][count] += PY;
            //ZZ1[8][count] += PZ;
        }else{
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ1
        
        //OP: ZZ2 (Zig Zag) - along Y axis
        if((i % 2 == 0))
        {
            ZZ2[0][count] += (-1) * X;
            ZZ2[1][count] += (-1) * Y;
            ZZ2[2][count] += (-1) * Z;
            //ZZ2[3][count] += (-1) * XY;
            //ZZ2[4][count] += (-1) * YZ;
            //ZZ2[5][count] += (-1) * ZX;
            //ZZ2[6][count] += (-1) * PX;
            //ZZ2[7][count] += (-1) * PY;
            //ZZ2[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1))
        {
            ZZ2[0][count] += X;
            ZZ2[1][count] += Y;
            ZZ2[2][count] += Z;
            //ZZ2[3][count] += XY;
            //ZZ2[4][count] += YZ;
            //ZZ2[5][count] += ZX;
            //ZZ2[6][count] += PX;
            //ZZ2[7][count] += PY;
            //ZZ2[8][count] += PZ;
        }
        else
        {
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ2
        
        //OP: ZZ3 (Zig Zag) - perp to y axis (along
        if((i % 2 == 0) && (j % 2 == 0))
        {
            ZZ3[0][count] += X;
            ZZ3[1][count] += Y;
            ZZ3[2][count] += Z;
            //ZZ3[3][count] += XY;
            //ZZ3[4][count] += YZ;
            //ZZ3[5][count] += ZX;
            //ZZ3[6][count] += PX;
            //ZZ3[7][count] += PY;
            //ZZ3[8][count] += PZ;
        }
        else if((i % 2 == 0) && (j % 2 == 1))
        {
            ZZ3[0][count] += (-1) * X;
            ZZ3[1][count] += (-1) * Y;
            ZZ3[2][count] += (-1) * Z;
            //ZZ3[3][count] += (-1) * XY;
            //ZZ3[4][count] += (-1) * YZ;
            //ZZ3[5][count] += (-1) * ZX;
            //ZZ3[6][count] += (-1) * PX;
            //ZZ3[7][count] += (-1) * PY;
            //ZZ3[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1) && (j % 2 == 0))
        {
            ZZ3[0][count] += (-1) * X;
            ZZ3[1][count] += (-1) * Y;
            ZZ3[2][count] += (-1) * Z;
            //ZZ3[3][count] += (-1) * XY;
            //ZZ3[4][count] += (-1) * YZ;
            //ZZ3[5][count] += (-1) * ZX;
            //ZZ3[6][count] += (-1) * PX;
            //ZZ3[7][count] += (-1) * PY;
            //ZZ3[8][count] += (-1) * PZ;
        }
        else if((i % 2 == 1) && (j % 2 == 1))
        {
            ZZ3[0][count] += X;
            ZZ3[1][count] += Y;
            ZZ3[2][count] += Z;
            //ZZ3[3][count] += XY;
            //ZZ3[4][count] += YZ;
            //ZZ3[5][count] += ZX;
            //ZZ3[6][count] += PX;
            //ZZ3[7][count] += PY;
            //ZZ3[8][count] += PZ;
        }
        else
        {
            std::cerr << "Shouldn't occur" << std::endl;
            exit(1);
        }
        //End OP: ZZ3
        
        //OP: TB
        TB[count] = getPolarAngleTB(X,Y,Z);
        //End OP: TB
        
        //OP: AB
        AB[count] = getAziAngleAB(X,Y,Z);
        //End OP: AB
        
    }
    
    
    double OPArr[NUMVECTORS][SPINDIMEN][NUMCORRSPINSBIG] = {0};
    const int DIMOFB = 2;
    double bOP[NUMVECTORS][DIMOFB][NUMCORRSPINSBIG] = {0};
    double mOP[NUMVECTORS][DIMOFB][NUMCORRSPINSBIG] = {0};
    
    for(int i = 0; i < SPINDIMEN; i++){
        for(int j = 0; j < 2*MCP.cellsA; j++){
            OPArr[0][i][j] = M[i][j];
            OPArr[1][i][j] = N[i][j];
            OPArr[2][i][j] = S1[i][j];
            OPArr[3][i][j] = S2[i][j];
            OPArr[4][i][j] = S3[i][j];
            OPArr[5][i][j] = sqrt(S1[i][j]*S1[i][j] +
                                  S2[i][j]*S2[i][j] +
                                  S3[i][j]*S3[i][j]);
            
            OPArr[6][i][j] = N3D[i][j];
            OPArr[7][i][j] = ZZ1[i][j];
            OPArr[8][i][j] = ZZ2[i][j];
            OPArr[9][i][j] = ZZ3[i][j];
            OPArr[10][i][j] = sqrt(ZZ1[i][j]*ZZ1[i][j] +
                                   ZZ2[i][j]*ZZ2[i][j] +
                                   ZZ3[i][j]*ZZ3[i][j]);
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int k = 0; k < 2*MCP.cellsA; k++){
            
            double a1 = 0;
            double a2 = PI/3.0;
            double a3 = 2*PI/3.0;
            double a4 = PI;
            double a5 = 4*PI/3.0;
            double a6 = 5*PI/3.0;
            
            /*
             double tempB1 = (snapOP[i][0]*snapOP[i][0] +
             snapOP[i][1]*snapOP[i][1] -
             2*snapOP[i][2]*snapOP[i][2])/sqrt(6.0);
             
             double tempB2 = (snapOP[i][0]*snapOP[i][0] -
             snapOP[i][1]*snapOP[i][1])/sqrt(2.0);
             */
            
            double tempB1 = 0;
            double tempB2 = 0;
            
            tempB1 += fabs(OPArr[i][0][k])*cos(a1);
            tempB2 += fabs(OPArr[i][0][k])*sin(a1);
            
            tempB1 += fabs(OPArr[i][1][k])*cos(a3);
            tempB2 += fabs(OPArr[i][1][k])*sin(a3);
            
            tempB1 += fabs(OPArr[i][2][k])*cos(a5);
            tempB2 += fabs(OPArr[i][2][k])*sin(a5);
            
            //b1, b2
            bOP[i][0][k] = tempB1;
            bOP[i][1][k] = tempB2;
            
            //m
            double tempM1 = 0;
            double tempM2 = 0;
            
            if(OPArr[i][0] > 0){
                tempM1 += fabs(OPArr[i][0][k])*cos(a2);
                tempM2 += fabs(OPArr[i][0][k])*sin(a2);
            }else{
                tempM1 += fabs(OPArr[i][0][k])*cos(a5);
                tempM2 += fabs(OPArr[i][0][k])*sin(a5);
            }
            
            if(OPArr[i][1] > 0){
                tempM1 += fabs(OPArr[i][1][k])*cos(a1);
                tempM2 += fabs(OPArr[i][1][k])*sin(a1);
            }else{
                tempM1 += fabs(OPArr[i][1][k])*cos(a4);
                tempM2 += fabs(OPArr[i][1][k])*sin(a4);
            }
            
            if(OPArr[i][2] > 0){
                tempM1 += fabs(OPArr[i][2][k])*cos(a6);
                tempM2 += fabs(OPArr[i][2][k])*sin(a6);
            }else{
                tempM1 += fabs(OPArr[i][2][k])*cos(a3);
                tempM2 += fabs(OPArr[i][2][k])*sin(a3);
            }
            
            //m1, m2
            mOP[i][0][k] = tempM1;
            mOP[i][1][k] = tempM2;
            
        }
    }
    
    //Calculate correlation function, dot products of spins
    for(int i = 0; i < NUMVECTORS; i++){
        
        //OP:
        for(int count = 0; count < 2*MCP.cellsA; count++){
            OP.corrFunc[i][0][count] = (OPArr[i][0][0] * OPArr[i][0][count] +
                                        OPArr[i][1][0] * OPArr[i][1][count] +
                                        OPArr[i][2][0] * OPArr[i][2][count]);
            
            //b OP:
            OP.corrFunc[i][1][count] = (bOP[i][0][0] * bOP[i][0][count]);
            
            OP.corrFunc[i][2][count] = (bOP[i][0][0] * bOP[i][0][count]);
            
            OP.corrFunc[i][3][count] = (bOP[i][0][0] * bOP[i][0][count] +
                                        bOP[i][1][0] * bOP[i][1][count]);
            
            //m OP:
            OP.corrFunc[i][4][count] = (mOP[i][0][0] * mOP[i][0][count]);
            
            OP.corrFunc[i][5][count] = (mOP[i][1][0] * mOP[i][1][count]);
            
            OP.corrFunc[i][6][count] = (mOP[i][0][0] * mOP[i][0][count] +
                                        mOP[i][1][0] * mOP[i][1][count]);
            
            //spin components
            OP.corrFunc[i][7][count] = OPArr[i][0][0] * OPArr[i][0][count];
            
            OP.corrFunc[i][8][count] = OPArr[i][1][0] * OPArr[i][1][count];
            
            OP.corrFunc[i][9][count] = OPArr[i][2][0] * OPArr[i][2][count];
            
            //OP.corrFunc[i][10][count] = OPArr[i][3][0] * OPArr[i][3][count];
            
            //OP.corrFunc[i][11][count] = OPArr[i][4][0] * OPArr[i][4][count];
            
            //OP.corrFunc[i][12][count] = OPArr[i][5][0] * OPArr[i][5][count];
            
            //OP.corrFunc[i][13][count] = OPArr[i][6][0] * OPArr[i][6][count];
            
            //OP.corrFunc[i][14][count] = OPArr[i][7][0] * OPArr[i][7][count];
            
            //OP.corrFunc[i][15][count] = OPArr[i][8][0] * OPArr[i][8][count];
            
            //OP.corrFunc[i][16][count] = (OPArr[i][6][0] * OPArr[i][6][count] +
            //                             OPArr[i][7][0] * OPArr[i][7][count] +
            //                             OPArr[i][8][0] * OPArr[i][8][count]);
            
        }
    }
    
    for(int count = 0; count < 2*MCP.cellsA; count++){
        OP.ECorrFunc[count] = E[0] * E[count];
        OP.TBCorrFunc[count] = TB[0] * TB[count];
        OP.ABCorrFunc[count] = AB[0] * AB[count];
    }
    
    
};

void MonteCarlo::updateFourierTransformOnRecipLattice(){
    const double numSites = MCP.cellsA *MCP.cellsB * MCP.cellsC * 2;
    //Loop over all k points
    for(int k_i = 0; k_i < MCP.cellsA; k_i++){
        for(int k_j = 0; k_j < MCP.cellsB; k_j++){
            
            //Loop over all sites in real space
            for(int i = 0; i < MCP.cellsA; i++){
                for(int j = 0; j < MCP.cellsB; j++){
                    
                    //sublattice A
                    //Divide by cells in order to stay in first BZ
                    double kvector_x = k_i * B_VECTOR_1[0] / (MCP.cellsA*1.0) + k_j * B_VECTOR_2[0] / (MCP.cellsB*1.0);
                    double kvector_y = k_i * B_VECTOR_1[1] / (MCP.cellsA*1.0) + k_j * B_VECTOR_2[1] / (MCP.cellsB*1.0);
                    double rvector_x = i * A_VECTOR_1[0] + j * A_VECTOR_2[0];
                    double rvector_y = i * A_VECTOR_1[1] + j * A_VECTOR_2[1];
                    double kr = kvector_x * rvector_x + kvector_y * rvector_y;
                    recipLattice[k_i][k_j][0][0].ReXComponent += cos(kr) * lattice[i][j][0][0].getX() / (numSites*1.0);//A,B,s,C,x/y/z/ix/iy/iz
                    recipLattice[k_i][k_j][0][0].ImXComponent += sin(kr) * lattice[i][j][0][0].getX() / (numSites*1.0);
                    recipLattice[k_i][k_j][0][0].ReYComponent += cos(kr) * lattice[i][j][0][0].getY() / (numSites*1.0);
                    recipLattice[k_i][k_j][0][0].ImYComponent += sin(kr) * lattice[i][j][0][0].getY() / (numSites*1.0);
                    recipLattice[k_i][k_j][0][0].ReZComponent += cos(kr) * lattice[i][j][0][0].getZ() / (numSites*1.0);
                    recipLattice[k_i][k_j][0][0].ImZComponent += sin(kr) * lattice[i][j][0][0].getZ() / (numSites*1.0);
                    
                    //sublattice B
                    rvector_y = i * A_VECTOR_1[1] + j * A_VECTOR_2[1] + 1/sqrt(3.0);
                    kr = kvector_x * rvector_x + kvector_y * rvector_y;
                    recipLattice[k_i][k_j][1][0].ReXComponent += cos(kr) * lattice[i][j][1][0].getX() / (numSites*1.0);//A,B,s,C,x/y/z/ix/iy/iz
                    recipLattice[k_i][k_j][1][0].ImXComponent += sin(kr) * lattice[i][j][1][0].getX() / (numSites*1.0);
                    recipLattice[k_i][k_j][1][0].ReYComponent += cos(kr) * lattice[i][j][1][0].getY() / (numSites*1.0);
                    recipLattice[k_i][k_j][1][0].ImYComponent += sin(kr) * lattice[i][j][1][0].getY() / (numSites*1.0);
                    recipLattice[k_i][k_j][1][0].ReZComponent += cos(kr) * lattice[i][j][1][0].getZ() / (numSites*1.0);
                    recipLattice[k_i][k_j][1][0].ImZComponent += sin(kr) * lattice[i][j][1][0].getZ() / (numSites*1.0);
                    
                }
            }
            
            
            recipLattice[k_i][k_j][0][0].magnitude = (
                                                      recipLattice[k_i][k_j][0][0].ReXComponent * recipLattice[k_i][k_j][0][0].ReXComponent +
                                                      recipLattice[k_i][k_j][0][0].ReYComponent * recipLattice[k_i][k_j][0][0].ReYComponent +
                                                      recipLattice[k_i][k_j][0][0].ReZComponent * recipLattice[k_i][k_j][0][0].ReZComponent +
                                                      recipLattice[k_i][k_j][0][0].ImXComponent * recipLattice[k_i][k_j][0][0].ImXComponent +
                                                      recipLattice[k_i][k_j][0][0].ImYComponent * recipLattice[k_i][k_j][0][0].ImYComponent +
                                                      recipLattice[k_i][k_j][0][0].ImZComponent * recipLattice[k_i][k_j][0][0].ImZComponent
                                                      );
            
            recipLattice[k_i][k_j][1][0].magnitude = (
                                                      recipLattice[k_i][k_j][1][0].ReXComponent * recipLattice[k_i][k_j][1][0].ReXComponent +
                                                      recipLattice[k_i][k_j][1][0].ReYComponent * recipLattice[k_i][k_j][1][0].ReYComponent +
                                                      recipLattice[k_i][k_j][1][0].ReZComponent * recipLattice[k_i][k_j][1][0].ReZComponent +
                                                      recipLattice[k_i][k_j][1][0].ImXComponent * recipLattice[k_i][k_j][1][0].ImXComponent +
                                                      recipLattice[k_i][k_j][1][0].ImYComponent * recipLattice[k_i][k_j][1][0].ImYComponent +
                                                      recipLattice[k_i][k_j][1][0].ImZComponent * recipLattice[k_i][k_j][1][0].ImZComponent
                                                      );
            
        }
    }
}

void MonteCarlo::addToMagStats(){
    
    updateOrderParameters();
    
    //E
    LC.sumE[0] += OP.E;
    LC.sumE[1] += OP.E*OP.E;
    LC.sumE[2] += (OP.E*OP.E) * OP.E;
    LC.sumE[3] += (OP.E*OP.E) * (OP.E*OP.E);
    
    //TB
    LC.sumTB[0] += OP.TB;
    LC.sumTB[1] += OP.TB*OP.TB;
    LC.sumTB[2] += (OP.TB*OP.TB) * OP.TB;
    LC.sumTB[3] += (OP.TB*OP.TB) * (OP.TB*OP.TB);
    
    //AB
    LC.sumAB[0] += OP.AB;
    LC.sumAB[1] += OP.AB*OP.AB;
    LC.sumAB[2] += (OP.AB*OP.AB) * OP.AB;
    LC.sumAB[3] += (OP.AB*OP.AB) * (OP.AB*OP.AB);
    
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            
            double temp2 = OP.charOP[i][j]*OP.charOP[i][j];
            
            LC.sumOP[i][j][0] += OP.charOP[i][j];
            LC.sumOP[i][j][1] += temp2;
            LC.sumOP[i][j][2] += OP.charOP[i][j]*temp2;
            LC.sumOP[i][j][3] += temp2*temp2;
        }
    }
    
    if((MD.numConfigsDone % CORRTOUPDATES == 0)&&(MD.numConfigsDone > 0)){
        //Correlation Function
        for(int count = 0; count < 2*MCP.cellsA; count++){
            LC.sumECorrFunc[count] += OP.ECorrFunc[count];
        }
        for(int count = 0; count < 2*MCP.cellsA; count++){
            LC.sumTBCorrFunc[count] += OP.TBCorrFunc[count];
        }
        for(int count = 0; count < 2*MCP.cellsA; count++){
            LC.sumABCorrFunc[count] += OP.ABCorrFunc[count];
        }
        
        for(int count = 0; count < 2*MCP.cellsA; count++){
            for(int i = 0; i < NUMVECTORS; i++){
                for(int j = 0; j < TYPESOP; j++){
                    LC.sumOPCorrFunc[i][j][count] += OP.corrFunc[i][j][count];
                }
            }
        }
    }
    
    if((MD.numConfigsDone % FTTOUPDATES == 0)&&(MD.numConfigsDone > 0)){
        //Loop over all k points
        for(int k_i = 0; k_i < MCP.cellsA; k_i++){
            for(int k_j = 0; k_j < MCP.cellsB; k_j++){
                
                //sublattice A
                sumOverRecipLattice[k_i][k_j][0][0].ReXComponent += recipLattice[k_i][k_j][0][0].ReXComponent;//A,B,s,C,x/y/z/ix/iy/iz
                sumOverRecipLattice[k_i][k_j][0][0].ImXComponent += recipLattice[k_i][k_j][0][0].ReYComponent;
                sumOverRecipLattice[k_i][k_j][0][0].ReYComponent += recipLattice[k_i][k_j][0][0].ReZComponent;
                sumOverRecipLattice[k_i][k_j][0][0].ImYComponent += recipLattice[k_i][k_j][0][0].ImXComponent;
                sumOverRecipLattice[k_i][k_j][0][0].ReZComponent += recipLattice[k_i][k_j][0][0].ImYComponent;
                sumOverRecipLattice[k_i][k_j][0][0].ImZComponent += recipLattice[k_i][k_j][0][0].ImZComponent;
                sumOverRecipLattice[k_i][k_j][0][0].magnitude += recipLattice[k_i][k_j][0][0].magnitude;
                
                //sublattice B
                sumOverRecipLattice[k_i][k_j][1][0].ReXComponent += recipLattice[k_i][k_j][1][0].ReXComponent;//A,B,s,C,x/y/z/ix/iy/iz
                sumOverRecipLattice[k_i][k_j][1][0].ImXComponent += recipLattice[k_i][k_j][1][0].ReYComponent;
                sumOverRecipLattice[k_i][k_j][1][0].ReYComponent += recipLattice[k_i][k_j][1][0].ReZComponent;
                sumOverRecipLattice[k_i][k_j][1][0].ImYComponent += recipLattice[k_i][k_j][1][0].ImXComponent;
                sumOverRecipLattice[k_i][k_j][1][0].ReZComponent += recipLattice[k_i][k_j][1][0].ImYComponent;
                sumOverRecipLattice[k_i][k_j][1][0].ImZComponent += recipLattice[k_i][k_j][1][0].ImZComponent;
                sumOverRecipLattice[k_i][k_j][1][0].magnitude += recipLattice[k_i][k_j][1][0].magnitude;
                
            }
        }
    }
    
    MD.numConfigsDone++;
    if(MD.numConfigsDone % (10 * 1000) == 0){
        adjustRange();
    }
}

void MonteCarlo::sweep(int numIndep_, double durationOfSingleRun){
    
    for(int sweeps = MD.numSweepsPerformed; sweeps <= MCP.numSweepsToPerformTotal; sweeps++)
    {
        
        
        metropolisSweep();
        MD.numSweepsPerformed += 1;
        if(sweeps % numIndep_ == 0)
        {
            addToMagStats();
            
            
            double clocks = clock() - MD.timeOfInitialization;
            double hoursElapsed = clocks * (1.0/(CLOCKS_PER_SEC*1.0)) / (60 * 60);
            if(hoursElapsed > durationOfSingleRun)
            {
                cout<<"Ran out of time, in sweep()"<<endl;
                break;
            }
            
            
        }
        
    }
    
    cout<<"finished print(), in sweep()"<<endl;
    
}

void MonteCarlo::sweepSnapshot(int numSweeps_, int numIndep_, double hours_){
    /*
     clock_t start = clock();
     while((clock() - start) * (1/(CLOCKS_PER_SEC*1.0)) < (hours_*60*60) )
     {
     double KbT_ = KbT;
     thermalize(KbT_ * 64);
     thermalize(KbT_ * 16);
     thermalize(KbT_ * 4);
     thermalize(KbT_ * 2);
     thermalize(KbT_);
     int swept = 0;
     for(int sweeps = 1; sweeps <= numSweeps_; sweeps++)
     {
     metropolisSweep();
     if(sweeps % numIndep_ == 0)
     {
     printSnapshot();
     }
     
     if((clock() - start) * (1/(CLOCKS_PER_SEC*1.0)) > (hours_*60*60) ){
     swept = sweeps;
     break;
     }
     
     }
     
     //
     std::stringstream stream;
     std::ofstream fileOut;
     
     stringstream out;
     out.str("");
     string temp = outputMag.substr(0,outputMag.size()-4);
     out << temp.c_str() << "OPSnap.txt";
     
     fileOut.open(out.str().c_str(), std::ios::out | std::ios::app);
     stream.str("");
     
     stream << "Done with one run of sweepSnapshot(), consisting of " << swept;
     stream << " runs, skipping every " << numIndep_ << " sweep." <<endl;
     
     fileOut << stream.str() << std::endl;
     fileOut.close();
     //
     
     }
     
     cout<<"finished finalPrint(), in sweepSnapshot()"<<endl;
     */
}


void MonteCarlo::finalPrint(){
    
    updateOrderParameters();
    
    //Averaging.
    double aveE[POWERSOP] = {0};
    double aveTB[POWERSOP] = {0};
    double aveAB[POWERSOP] = {0};
    double aveOP[NUMVECTORS][TYPESOP][POWERSOP] = {0};
    
    //E
    aveE[0] = LC.sumE[0] / (MD.numConfigsDone*1.0);
    aveE[1] = LC.sumE[1] / (MD.numConfigsDone*1.0);
    aveE[2] = LC.sumE[2] / (MD.numConfigsDone*1.0);
    aveE[3] = LC.sumE[3] / (MD.numConfigsDone*1.0);//not divided by numSites yet.
    //TB
    aveTB[0] = LC.sumTB[0] / (MD.numConfigsDone*1.0);
    aveTB[1] = LC.sumTB[1] / (MD.numConfigsDone*1.0);
    aveTB[2] = LC.sumTB[2] / (MD.numConfigsDone*1.0);
    aveTB[3] = LC.sumTB[3] / (MD.numConfigsDone*1.0);
    //AB
    aveAB[0] = LC.sumAB[0] / (MD.numConfigsDone*1.0);
    aveAB[1] = LC.sumAB[1] / (MD.numConfigsDone*1.0);
    aveAB[2] = LC.sumAB[2] / (MD.numConfigsDone*1.0);
    aveAB[3] = LC.sumAB[3] / (MD.numConfigsDone*1.0);
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            for(int k = 0; k < POWERSOP; k++){
                aveOP[i][j][k] = LC.sumOP[i][j][k] / (MD.numConfigsDone*1.0);
            }
        }
    }
    
    //Calculate Lattice Quantity
    double suscep[NUMVECTORS][TYPESOP] = {0};
    double binder[NUMVECTORS][TYPESOP] = {0};
    double spHeat = 0;
    
    double numSites = MCP.cellsA * MCP.cellsB * MCP.cellsC * 2.0;
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            suscep[i][j] = numSites*(aveOP[i][j][1] - aveOP[i][j][0]*aveOP[i][j][0])/MCP.KbT;
            binder[i][j] = 1.0 - aveOP[i][j][3]/(3.0*aveOP[i][j][1]*aveOP[i][j][1]);
        }
    }
    spHeat = (aveE[1] - (aveE[0]*aveE[0])) / (MCP.KbT*MCP.KbT*numSites);
    
    //Printing out info
    std::stringstream stream;
    std::ofstream fileOut;
    time_t t = time(0);
    tm time = *localtime(&t);
    
    fileOut.open(outputMag.c_str(), std::ios::out | std::ios::trunc);
    if (!fileOut.is_open() || !fileOut.good()){
        cerr << "Can't open file: " << endl;
        cerr << outputMag <<endl;
        exit(3161990);
    }
    stream.str("");
    stream << "Start characteristics for this configuration" << endl;
    stream << "Time: " << std::setw(2) << std::setfill('0') <<
    time.tm_mon + 1 << "_" << std::setw(2) << std::setfill('0') <<
    time.tm_mday << "_" << time.tm_year + 1900 << "_" << time.tm_hour + 1 << endl;
    if((MD.successfulFlips/MD.flipAttempts) * 100 < 50){
        cerr << "Alert! acceptance rate is too low!" << endl;
        cerr << "Flip Success percentage: " << MD.successfulFlips/MD.flipAttempts<<endl;
        cerr << "Range: " << MD.range <<endl;
        stream << "Alert! acceptance rate is too low!" << endl;
        stream << "Flip Success percentage: " << MD.successfulFlips/MD.flipAttempts<<endl;
        stream << "Range: " << MD.range <<endl;
    }
    
    stream << toString();
    
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, " << charOPNames[i][j] << ": " <<
            std::scientific << std::setprecision(PR) << aveOP[i][j][0] << endl;
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, Susceptibility - " << charOPNames[i][j] << ": "<<
            std::scientific << std::setprecision(PR) << suscep[i][j] << endl;
        }
    }
    
    for(int i = 0; i < NUMVECTORS; i++){
        for(int j = 0; j < TYPESOP; j++){
            stream << "Lattice Averaged Quantity, Binder - " << charOPNames[i][j] << ": "<<
            std::scientific << std::setprecision(PR) << binder[i][j] << endl;
        }
    }
    
    //E
    stream << "Lattice Averaged Quantity, Energy to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[0] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[1] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[2] << endl;
    stream << "Lattice Averaged Quantity, Energy to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveE[3] << endl;
    //TB
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[0] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[1] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[2] << endl;
    stream << "Lattice Averaged Quantity, Polar Angle to B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveTB[3] << endl;
    //AB
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 1st power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[0] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 2nd power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[1] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 3rd power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[2] << endl;
    stream << "Lattice Averaged Quantity, Azimuthal Angle to the B Field to the 4th power: ";
    stream << std::scientific << std::setprecision(PR) << aveAB[3] << endl;
    //
    
    
    stream << "Specific Heat: ";
    stream << std::scientific << std::setprecision(PR) << spHeat << endl;
    stream << "Energy Per Site: " << std::scientific <<
    std::setprecision(PR) << aveE[0] / numSites << endl;
    stream << "End information for this configuration" << endl;
    stream << endl;
    fileOut << stream.str() << std::endl;
    //std::cout << stream.str() << std::endl;
    fileOut.close();
    //printDiagram();
    
}

void MonteCarlo::printSnapshot(){
    /*
     updateOrderParameters();
     
     std::stringstream stream;
     std::ofstream fileOut;
     
     stringstream out;
     out.str("");
     string temp = outputMag.substr(0,outputMag.size()-4);
     out << temp.c_str() << "OPSnap.txt";
     
     fileOut.open(out.str().c_str(), std::ios::out | std::ios::app);
     stream.str("");
     
     /*
     for(int i = 0; i < NUMVECTORS; i++){
     for(int j = 0; j < SPINDIMEN; j++){
     stream << snapOPNamesSmall[i][j] << ": ";
     stream << std::scientific << std::setprecision(PR) << OP.snapOP[i][j] << endl;
     }
     }
     stream << "E: ";
     stream << std::scientific << std::setprecision(PR) << OP.E << endl;
     */
    /*
     double a1 = 0;
     double a2 = PI/3.0;
     double a3 = 2*PI/3.0;
     double a4 = PI;
     double a5 = 4*PI/3.0;
     double a6 = 5*PI/3.0;
     
     double m1 = 0;
     double m2 = 0;
     
     double N_X = OP.charOP[1][0];
     double N_Y = OP.charOP[1][1];
     double N_Z = OP.charOP[1][2];
     
     if(N_X > 0){m1 += fabs(N_X)*cos(a2); m2 += fabs(N_X)*sin(a2);}
     else       {m1 += fabs(N_X)*cos(a5); m2 += fabs(N_X)*sin(a5);}
     
     if(N_Y > 0){m1 += fabs(N_Y)*cos(a1); m2 += fabs(N_Y)*sin(a1);}
     else       {m1 += fabs(N_Y)*cos(a4); m2 += fabs(N_Y)*sin(a4);}
     
     if(N_Z > 0){m1 += fabs(N_Z)*cos(a6); m2 += fabs(N_Z)*sin(a6);}
     else       {m1 += fabs(N_Z)*cos(a3); m2 += fabs(N_Z)*sin(a3);}
     
     stream << "MN: " << std::scientific << std::setprecision(PR) << m1;
     stream << ", " << std::scientific << std::setprecision(PR) << m2 << endl;
     
     fileOut << stream.str() << std::endl;
     fileOut.close();
     */
    
}

void MonteCarlo::SetDomainWall(){
    
    
    //Neel Z, -Y
    //radius = cellsA/2 & cellsA/2 -1
    //Each set of three spins must be a normalized vector.
    
    int radius1 = MCP.cellsA/2 -1;
    double spin1X = 0;
    double spin1Y = 0;
    double spin1Z = 1;
    
    int radius2 = MCP.cellsA/2;
    double spin2X = 0;
    double spin2Y = -1;
    double spin2Z = 0;
    
    
    /*
     //Neel Z, -X
     //radius = cellsA/2 & cellsA/2 -1
     //Each set of three spins must be a normalized vector.
     
     int radius1 = cellsA/2 -1;
     double spin1X = 0;
     double spin1Y = 0;
     double spin1Z = 1;
     
     int radius2 = cellsA/2;
     double spin2X = -1;
     double spin2Y = 0;
     double spin2Z = 0;
     */
    
    /*
     //Neel Z, -Z
     //radius = cellsA/2 & cellsA/2 -1
     //Each set of three spins must be a normalized vector.
     
     int radius1 = cellsA/2 -1;
     double spin1X = 0;
     double spin1Y = 0;
     double spin1Z = 1;
     
     int radius2 = cellsA/2;
     double spin2X = 0;
     double spin2Y = 0;
     double spin2Z = -1;
     */
    
    /*
     //Neel Z, X
     //radius = cellsA/2 & cellsA/2 -1
     //Each set of three spins must be a normalized vector.
     
     int radius1 = cellsA/2 -1;
     double spin1X = 0;
     double spin1Y = 0;
     double spin1Z = 1;
     
     int radius2 = cellsA/2;
     double spin2X = 1;
     double spin2Y = 0;
     double spin2Z = 0;
     */
    
    /*
     //Neel Z, Y
     //radius = cellsA/2 & cellsA/2 -1
     //Each set of three spins must be a normalized vector.
     
     int radius1 = cellsA/2 -1;
     double spin1X = 0;
     double spin1Y = 0;
     double spin1Z = 1;
     
     int radius2 = cellsA/2;
     double spin2X = 0;
     double spin2Y = 1;
     double spin2Z = 0;
     */
    
    /*
     //Neel Z, Z
     //radius = cellsA/2 & cellsA/2 -1
     //Each set of three spins must be a normalized vector.
     
     int radius1 = cellsA/2 -1;
     double spin1X = 0;
     double spin1Y = 0;
     double spin1Z = 1;
     
     int radius2 = cellsA/2;
     double spin2X = 0;
     double spin2Y = 0;
     double spin2Z = 1;
     */
    
    
    SetDomainWallSpins(spin1X,spin1Y,spin1Z,radius1,//inner wall
                       spin2X,spin2Y,spin2Z,radius2//outer wall
                       );
}

void MonteCarlo::SetDomainWallSpins(double spin1X, double spin1Y, double spin1Z, int radius1,//inner wall
                                    double spin2X, double spin2Y, double spin2Z, int radius2//outer wall
){
    //cout<<"Start Making Domain Wall"<<endl;
    //Only Implemented for Neel Order
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int k = 0; k < 2; k++){
                for(int z = 0; z < MCP.cellsC; z++){
                    //cout<<"i = " << i << " j = " << j << " k = " << k << " z = " << z;
                    if(isDomain(i, j, k, z, radius1)){
                        //if k == 0 - count negative M, k == 1 - positive M
                        lattice[i][j][k][z].setX((2 * k - 1) * spin1X);
                        lattice[i][j][k][z].setY((2 * k - 1) * spin1Y);
                        lattice[i][j][k][z].setZ((2 * k - 1) * spin1Z);
                        //cout<< " <- Dom1";
                    }
                    
                    if(isDomain(i, j, k, z, radius2)){
                        //if k == 0 - count negative M, k == 1 - positive M
                        lattice[i][j][k][z].setX((2 * k - 1) * spin2X);
                        lattice[i][j][k][z].setY((2 * k - 1) * spin2Y);
                        lattice[i][j][k][z].setZ((2 * k - 1) * spin2Z);
                        //cout<< " <- Dom2";
                    }
                    //cout<<endl;
                }
            }
        }
    }
    //cout<<"End Making Domain Wall"<<endl;
    //exit(0);
}

bool MonteCarlo::isDomain(int i, int j, int k, int z, int radius){
    //indepedant of z
    
    int startPosX = MCP.cellsA/2;
    
    //left side
    if((k == 1)&&(i == (startPosX - radius))&&(j == 0)){
        return true;
    }
    if((i == (startPosX - radius))&&(j > 0)&&(j <= radius -1)){
        return true;
    }
    
    //top side
    if((k == 0)&&(i <= (startPosX -1))&&(i >= (startPosX - radius))&&(j == radius)){
        return true;
    }
    if((k == 1)&&(i <= (startPosX -1))&&(i >= (startPosX - radius +1))&&(j == radius-1)){
        return true;
    }
    
    //right side
    if((i >= startPosX)&&((i - startPosX) + j == radius -1)&&
       (
        (j != 0)||((k == 1)&&(j == 0))
        )
       ){
        return true;
    }
    
    return false;
}

double MonteCarlo::getLocalEnergy(const ClassicalSpin3D& a, const bool fromSpinFlip) const{
    double totalInteraction = 0;
    double spinX = a.getX();
    double spinY = a.getY();
    double spinZ = a.getZ();
    int spinPosX = a.getPosX();
    int spinPosY = a.getPosY();
    int spinPosS = a.getPosS();
    ClassicalSpin3D a1_x = getSpinInTheXDir(a);
    ClassicalSpin3D a1_y = getSpinInTheYDir(a);
    ClassicalSpin3D a1_z = getSpinInTheZDir(a);
    
    if(MCP.isCubeHam)
    {
        double interaction1 = 0;
        
        if(fromSpinFlip){
            interaction1 = (-1) * MCP.cubicD * (spinX*spinX*spinX*spinX +
                                                spinY*spinY*spinY*spinY +
                                                spinZ*spinZ*spinZ*spinZ);
        }else if(!fromSpinFlip){//From Finding the total E of the lattice
            interaction1 = (-1) * MCP.cubicD * (spinX*spinX*spinX*spinX +
                                                spinY*spinY*spinY*spinY +
                                                spinZ*spinZ*spinZ*spinZ)/2;
        }
        
        totalInteraction += interaction1;
    }
    
    //Rotated Hamiltonian
    if(MCP.isRotHam)
    {
        
        //Determine the sublattice of a
        if((spinPosX % 2 == 0)&&(spinPosY % 2 == 1)&&(spinPosS == 0)||
           (spinPosX % 2 == 1)&&(spinPosY % 2 == 1)&&(spinPosS == 1))
        {
            //Black circle sublattice = A
            //Spin is unchanged
        }
        if((spinPosX % 2 == 0)&&(spinPosY % 2 == 0)&&(spinPosS == 1)||
           (spinPosX % 2 == 1)&&(spinPosY % 2 == 0)&&(spinPosS == 0))
        {
            //Black square sublattice = B
            spinY = (-1.0) * spinY;
            spinZ = (-1.0) * spinZ;
        }
        if((spinPosX % 2 == 0)&&(spinPosY % 2 == 0)&&(spinPosS == 0)||
           (spinPosX % 2 == 1)&&(spinPosY % 2 == 0)&&(spinPosS == 1))
        {
            //white square sublattice = C
            spinX = (-1.0) * spinX;
            spinZ = (-1.0) * spinZ;
        }
        if((spinPosX % 2 == 0)&&(spinPosY % 2 == 1)&&(spinPosS == 1)||
           (spinPosX % 2 == 1)&&(spinPosY % 2 == 1)&&(spinPosS == 0))
        {
            //White circle sublattice = D
            spinX = (-1.0) * spinX;
            spinY = (-1.0) * spinY;
        }
        
        //Heisenberg interaction
        double interaction1 = (MCP.alpha - 1.0) * (a.dotProd(a1_x) +
                                                   a.dotProd(a1_y) +
                                                   a.dotProd(a1_z));
        
        //Kitaev interaction
        double interaction2 = (2.0 - 4.0*MCP.alpha) * (a1_x.getX() * spinX +
                                                       a1_y.getY() * spinY +
                                                       a1_z.getZ() * spinZ);
        
        
        if(fromSpinFlip)
        {
            totalInteraction += interaction1 + interaction2;
        }else
        {//From Finding the total E of the lattice
            totalInteraction += interaction1/2.0 + interaction2/2.0;
        }
        
    }
    
    if(MCP.isAlphaHam)
    {
        
        //Heisenberg interaction
        double interactionH = (a.dotProd(a1_x) +
                               a.dotProd(a1_y) +
                               a.dotProd(a1_z));
        
        double interactionK = (a1_x.getX() * spinX +
                               a1_y.getY() * spinY +
                               a1_z.getZ() * spinZ);
        
        if(fromSpinFlip){
            totalInteraction += (1-MCP.alpha)*(interactionH) + (-2.0*MCP.alpha) * (interactionK);
        }else{//From Finding the total E of the lattice
            totalInteraction += (1-MCP.alpha)*(interactionH/2.0) + (-2.0*MCP.alpha)*(interactionK/2.0);
        }
        
    }
    
    //Extended Hamiltonian
    if(MCP.isPhiHam)
    {
        //Heisenberg interaction
        //Normal rotated coords
        double interaction1 = cos(MCP.phi) * (a.dotProd(a1_x) +
                                              a.dotProd(a1_y) +
                                              a.dotProd(a1_z));
        //Kitaev interaction
        double interaction2 = 2 * sin(MCP.phi) * (a1_x.getX() * spinX +
                                                  a1_y.getY() * spinY +
                                                  a1_z.getZ() * spinZ);
        
        
        
        if(fromSpinFlip)
        {
            totalInteraction += interaction1 + interaction2;
        }else
        {//From Finding the total E of the lattice
            totalInteraction += interaction1/2.0 + interaction2/2.0;
        }
        
    }
    
    if(MCP.isJ23Term)
    {
        
        ClassicalSpin3D a2_xy = getSpinInTheYDir(a1_x);
        ClassicalSpin3D a2_yx = getSpinInTheXDir(a1_y);
        
        ClassicalSpin3D a2_xz = getSpinInTheZDir(a1_x);
        ClassicalSpin3D a2_zx = getSpinInTheXDir(a1_z);
        
        ClassicalSpin3D a2_yz = getSpinInTheZDir(a1_y);
        ClassicalSpin3D a2_zy = getSpinInTheYDir(a1_z);
        
        ClassicalSpin3D a3_1 = getSpinInTheZDir(a2_xy);
        ClassicalSpin3D a3_2 = getSpinInTheXDir(a2_yz);
        ClassicalSpin3D a3_3 = getSpinInTheYDir(a2_zx);
        
        double interactionH = 1.0 * (a.dotProd(a1_x) +
                                     a.dotProd(a1_y) +
                                     a.dotProd(a1_z));
        
        double interactionK = (-17/3.0)*(a1_x.getX() * spinX +
                                         a1_y.getY() * spinY +
                                         a1_z.getZ() * spinZ);
        
        //Heisenberg interaction
        //2nd Neighbor interaction
        double interactionH2 = MCP.j2 * (a.dotProd(a2_xy) + a.dotProd(a2_xz) +
                                         a.dotProd(a2_yz) + a.dotProd(a2_yx) +
                                         a.dotProd(a2_zx) + a.dotProd(a2_zy));
        
        //3rd Neighbor interaction
        double interactionH3 = MCP.j3 * (a.dotProd(a3_1) +
                                         a.dotProd(a3_2) +
                                         a.dotProd(a3_3));
        
        //Kitaev Interaction
        
        double interactionK2 = MCP.k2 * (a2_yz.getX() * spinX + a2_zy.getX() * spinX +
                                         a2_zx.getY() * spinY + a2_xz.getY() * spinY +
                                         a2_yx.getZ() * spinZ + a2_xy.getZ() * spinZ);
        
        if(fromSpinFlip)
        {
            totalInteraction += interactionH + interactionH2 + interactionH3 + interactionK + interactionK2;
        }else
        {//From Finding the total E of the lattice
            totalInteraction += (interactionH + interactionH2 + interactionH3 + interactionK + interactionK2) / 2.0;
        }
        
    }
    
    //B field
    if (MCP.isBField) {
        double interactionB = (-1) * (MCP.bField_xNorm * spinX +
                                      MCP.bField_yNorm * spinY +
                                      MCP.bField_zNorm * spinZ);
        totalInteraction += interactionB;
    }
    
    return totalInteraction;
    
}

inline const ClassicalSpin3D& MonteCarlo::getSpinInTheXDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(a.getPosS() == 0){
        if((aX == MCP.cellsA - 1) && (aY == MCP.cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aX == MCP.cellsA - 1) && (aY == 0)){
            return lattice[aX][MCP.cellsB - 1][1][aZ];
        }else if((aX == 0) && (aY == MCP.cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX][MCP.cellsB - 1][1][aZ];
        }else if((aX == 0)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aY == 0)){
            return lattice[aX][MCP.cellsB - 1][1][aZ];
        }else if((aX == MCP.cellsA - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else if((aY == MCP.cellsB - 1)){
            return lattice[aX][aY - 1][1][aZ];
        }else{
            return lattice[aX][aY - 1][1][aZ];
        }
    }else if(a.getPosS() == 1){
        if((aX == MCP.cellsA - 1) && (aY == MCP.cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else if((aX == MCP.cellsA - 1) && (aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == 0) && (aY == MCP.cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aY == 0)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aX == MCP.cellsA - 1)){
            return lattice[aX][aY + 1][0][aZ];
        }else if((aY == MCP.cellsB - 1)){
            return lattice[aX][0][0][aZ];
        }else{
            return lattice[aX][aY + 1][0][aZ];
        }
    }else{
        std::cerr << "Wrong sublattice" << std::endl;
        exit(1);
        return a;
    }
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheYDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(a.getPosS() == 0){
        if((aX == MCP.cellsA - 1) && (aY == MCP.cellsB - 1)){
            return lattice[0][aY - 1][1][aZ];
        }else if((aX == MCP.cellsA - 1) && (aY == 0)){
            return lattice[0][MCP.cellsB - 1][1][aZ];
        }else if((aX == 0) && (aY == MCP.cellsB - 1)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[aX + 1][MCP.cellsB - 1][1][aZ];
        }else if((aX == 0)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else if((aY == 0)){
            return lattice[aX + 1][MCP.cellsB - 1][1][aZ];
        }else if((aX == MCP.cellsA - 1)){
            return lattice[0][aY - 1][1][aZ];
        }else if((aY == MCP.cellsB - 1)){
            return lattice[aX + 1][aY - 1][1][aZ];
        }else{
            return lattice[aX + 1][aY - 1][1][aZ];
        }
    }else if(a.getPosS() == 1){
        if((aX == MCP.cellsA - 1) && (aY == MCP.cellsB - 1)){
            return lattice[aX - 1][0][0][aZ];
        }else if((aX == MCP.cellsA - 1) && (aY == 0)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aX == 0) && (aY == MCP.cellsB - 1)){
            return lattice[MCP.cellsA - 1][0][0][aZ];
        }else if((aX == 0) && (aY == 0)){
            return lattice[MCP.cellsA - 1][aY + 1][0][aZ];
        }else if((aX == 0)){
            return lattice[MCP.cellsA - 1][aY + 1][0][aZ];
        }else if((aY == 0)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aX == MCP.cellsA - 1)){
            return lattice[aX - 1][aY + 1][0][aZ];
        }else if((aY == MCP.cellsB - 1)){
            return lattice[aX - 1][0][0][aZ];
        }else{
            return lattice[aX - 1][aY + 1][0][aZ];
        }
    }else{
        std::cerr << "Wrong sublattice" << std::endl;
        exit(1);
        return a;
    }
    
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheUpDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(MCP.cellsC == 1){
        return a;
    }else{
        if(aZ == MCP.cellsC - 1){
            return lattice[aX][aY][a.getPosS()][0];
        }else if(aZ == 0){
            return lattice[aX][aY][a.getPosS()][aZ + 1];
        }else{
            return lattice[aX][aY][a.getPosS()][aZ + 1];
        }
    }
    return a;
}

const ClassicalSpin3D& MonteCarlo::getSpinInTheDownDir(const ClassicalSpin3D& a) const{
    int aX = a.getPosX();
    int aY = a.getPosY();
    int aZ = a.getPosZ();
    
    if(MCP.cellsC == 1){
        return a;
    }else{
        if(aZ == MCP.cellsC - 1){
            return lattice[aX][aY][a.getPosS()][aZ - 1];
        }else if(aZ == 0){
            return lattice[aX][aY][a.getPosS()][MCP.cellsC - 1];
        }else{
            return lattice[aX][aY][a.getPosS()][aZ - 1];
        }
    }
    return a;
    
}

void MonteCarlo::doC2Rotation001(){
    ClassicalSpin3D a;
    //cout<<"got here "<<endl;
    
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    a = lattice[i][j][k][z];
                    a.doC2Rotation001();
                    a.checkSpin();
                    //cout<<cellsA - a.getPosX()<<endl;
                    //cout<<cellsB - a.getPosY()<<endl;
                    //cout<<cellsC - a.getPosZ()<<endl;
                    //cout<<1 - a.getPosS()<<endl;
                    a.setPosX(MCP.cellsA - a.getPosX());
                    a.setPosY(MCP.cellsB - a.getPosY());
                    a.setPosZ(MCP.cellsC - a.getPosZ());
                    a.setPosS(1 - a.getPosS());
                }
            }
        }
    }
    //cout<<"got here psh"<<endl;
    
    std::vector< std::vector< std::vector< std::vector<ClassicalSpin3D> > > > temp;
    ClassicalSpin3D spin;
    for(int i = 0; i < MCP.cellsA; i++){
        std::vector< std::vector< std::vector<ClassicalSpin3D> > > row;
        for(int j = 0; j < MCP.cellsB; j++){
            std::vector< std::vector<ClassicalSpin3D> > col;
            for(int k = 0; k < 2; k++){
                std::vector<ClassicalSpin3D> rise;
                for(int z = 0; z < MCP.cellsC; z++){
                    
                    rise.push_back(spin);
                }
                col.push_back(rise);
            }
            row.push_back(col);
        }
        temp.push_back(row);
    }
    //cout<<"got here Whew"<<endl;
    
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    //cout<<i<<j<<z<<k<<endl;
                    //cout<<lattice[i][j][k][z].getPosX()<<endl;
                    temp[i][j][k][z].setPosX(lattice[i][j][k][z].getPosX());
                    temp[i][j][k][z].setPosY(lattice[i][j][k][z].getPosY());
                    temp[i][j][k][z].setPosZ(lattice[i][j][k][z].getPosZ());
                    temp[i][j][k][z].setPosS(lattice[i][j][k][z].getPosS());
                    temp[i][j][k][z].setX(lattice[i][j][k][z].getX());
                    temp[i][j][k][z].setY(lattice[i][j][k][z].getY());
                    temp[i][j][k][z].setZ(lattice[i][j][k][z].getZ());
                }
            }
        }
    }
    //cout<<"got here Whew!"<<endl;
    
    bool found = false;
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    //FindSpin
                    for(int i2 = 0; i2 < MCP.cellsA; i2++){
                        for(int j2 = 0; j2 < MCP.cellsB; j2++){
                            for(int z2 = 0; z2 < MCP.cellsC; z2++){
                                for(int k2 = 0; k2 < 2; k2++){
                                    spin = temp[i2][j2][k2][z2];
                                    //cout<<"spin"<<endl;
                                    //cout<<spin.getPosX()<<endl;
                                    //cout<<spin.getPosY()<<endl;
                                    //cout<<spin.getPosZ()<<endl;
                                    //cout<<spin.getPosS()<<endl;
                                    if(i == spin.getPosX() && j == spin.getPosY() &&
                                       z == spin.getPosZ() && k == spin.getPosS()){
                                        //cout<<i<<j<<z<<k<<endl;
                                        lattice[i][j][k][z].setPosX(temp[i][j][k][z].getPosX());
                                        lattice[i][j][k][z].setPosY(temp[i][j][k][z].getPosY());
                                        lattice[i][j][k][z].setPosZ(temp[i][j][k][z].getPosZ());
                                        lattice[i][j][k][z].setPosS(temp[i][j][k][z].getPosS());
                                        lattice[i][j][k][z].setX(temp[i][j][k][z].getX());
                                        lattice[i][j][k][z].setY(temp[i][j][k][z].getY());
                                        lattice[i][j][k][z].setZ(temp[i][j][k][z].getZ());
                                        found = true;
                                    }
                                }
                            }
                        }
                    }
                    if(!found){
                        cerr << "Failed to Find Spin" << endl;
                        exit(3161990);
                    }
                    found = false;
                    //
                }
            }
        }
    }
    
}

void MonteCarlo::rotateAllSpins(double phi, double theta){
    for(int i = 0; i < MCP.cellsA; i++){
        for(int j = 0; j < MCP.cellsB; j++){
            for(int z = 0; z < MCP.cellsC; z++){
                for(int k = 0; k < 2; k++){
                    lattice[i][j][k][z].specifyRotation(phi, theta);
                }
            }
        }
    }
}


